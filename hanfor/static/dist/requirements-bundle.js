/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"requirements": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./js/requirements.js","commons"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/datatables-advanced-search.js":
/*!******************************************!*\
  !*** ./js/datatables-advanced-search.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Search query grammar declarations.\nconst operators = {\":AND:\": 1, \":OR:\": 1};\nconst leftAssoc = {\":AND:\": 1, \":OR:\": 1};\nconst rightAssoc = {};\nconst parantheses = {\"(\": 1, \")\": 1};\nconst precedenceOf = {\":AND:\": 3, \":OR:\": 2};\n\n/**\n * SearchNode represents one node in a search expression used to filter the requirements table.\n */\nclass SearchNode {\n    constructor(value) {\n        this.left = false;\n        this.value = value;\n        this.right = false;\n        this.col_target = -1;\n        this.update_target();\n    }\n\n    update_target() {\n        const col_string_index = this.value.indexOf(':COL_INDEX_');\n        if (col_string_index >= 0) {\n            const target_index = parseInt(this.value.substring(col_string_index + 11, col_string_index + 13));\n            if (target_index >= 0) {\n                this.value = this.value.substring(col_string_index + 14);\n                this.col_target = target_index;\n            }\n        }\n    }\n\n    evaluate(data, visible_columns) {\n        return evaluateSearchExpressionTree(this, data, visible_columns);\n    }\n\n    static is_search_string(token) {\n        return !(token in parantheses || token in operators);\n    }\n\n    static to_string(tree) {\n        let repr = '';\n        if (tree.left !== false) {\n            repr += SearchNode.to_string(tree.left) + ' ';\n        }\n        repr += tree.value;\n        if (tree.right !== false) {\n            repr += ' ' + SearchNode.to_string(tree.right);\n        }\n        return repr;\n    }\n\n    static peek(array) {\n        return array[array.length - 1];\n    }\n\n    /**\n     * Parses a search array to a binary search tree using shunting yard algorithm.\n     * @param array\n     * @returns {*}\n     */\n    static searchArrayToTree(array) {\n\n        let output_tree_stack = [], op_stack = [];\n\n        for (let i = 0, length = array.length; i < length;  i++) {\n            const token = array[i]; // current token\n\n            // If token is a search string, add it to the output_tree_stack as a singleton tree.\n            if (SearchNode.is_search_string(token))\n                output_tree_stack.push(new SearchNode(token));\n\n            else if (token in operators) {\n                // We encountered an operator.\n                while (op_stack.length) {\n                    // As long as there is an operator (prev_op) at the top of the op_stack\n                    const prev_op = SearchNode.peek(op_stack);\n                    if (prev_op in operators && (\n                            // and token is left associative and precedence <= to that of prev_op,\n                            (token in leftAssoc &&\n                                (precedenceOf[token] <= precedenceOf[prev_op])) ||\n                            // or token is right associative and its precedence < to that of prev_op,\n                            (token in rightAssoc &&\n                                (precedenceOf[token] < precedenceOf[prev_op]))\n                        )) {\n                        // Pop last two subtrees and make them children of a new subtree (with prev_op as root).\n                        let right = output_tree_stack.pop(), left = output_tree_stack.pop();\n                        let sub_tree = new SearchNode(op_stack.pop());\n                        sub_tree.left = left;\n                        sub_tree.right = right;\n                        output_tree_stack.push(sub_tree);\n                    } else {\n                        break;\n                    }\n                }\n                op_stack.push(token);\n            }\n\n            // If token is opening parenthesis, just push to the op_stack.\n            else if (token === \"(\")\n                op_stack.push(token);\n\n            // If token is closing parenthesis:\n            else if (token === \")\") {\n\n                let has_opening_match = false;\n\n                // Search for opening paranthesis in op_stack.\n                while (op_stack.length) {\n                    const op = op_stack.pop();\n                    if (op === \"(\") {\n                        has_opening_match = true;\n                        break;\n                    } else {\n                        // Until match pop operators off the op_stack and create a new subtree with operator as root.\n                        let right = output_tree_stack.pop();\n                        let left = output_tree_stack.pop();\n                        let sub_tree = new SearchNode(op);\n                        sub_tree.left = left;\n                        sub_tree.right = right;\n                        output_tree_stack.push(sub_tree);\n                    }\n                }\n                if (!has_opening_match)\n                    throw \"Error: parentheses mismatch.\";\n            }\n            else throw \"Error: Token unknown: \" + token;\n        }\n\n        // No more tokens in input but operator tokens in the op_stack:\n        while (op_stack.length) {\n\n            const op = op_stack.pop();\n\n            if (op === \"(\" || op === \")\")\n                throw \"Error: Parentheses mismatch.\";\n\n            // Create new subtree with op as root.\n            let right = output_tree_stack.pop();\n            let left = output_tree_stack.pop();\n            let sub_tree = new SearchNode(op);\n            sub_tree.left = left;\n            sub_tree.right = right;\n            output_tree_stack.push(sub_tree);\n        }\n\n        // Empty stack => create empty dummy Node.\n        if (output_tree_stack.length === 0) {\n            output_tree_stack.push(new SearchNode(''));\n        }\n\n        // The last remaining node should be the root of our complete search tree.\n        return output_tree_stack[0];\n    }\n\n    /**\n     * Splits a search query into array where each element is one token.\n     * @param query\n     * @param target_col optional target col to restrict the search on a specific col.\n     * @returns {*|string[]}\n     */\n    static awesomeQuerySplitt0r(query, target_col=undefined) {\n        // Split by :AND:\n        let result = query.split(/(:OR:|:AND:|\\(|\\))/g);\n        result = result.filter(String); // Remove empty elements.\n        // If the resulting tree should be restricted to a col..\n        if (target_col !== undefined) {\n            for (let i = 0, length = result.length; i < length;  i++) {\n                // Add :COL_INDEX_<target_col>: to each search string (not a operator or parenthesis).\n                if (!(result[i] in operators || result[i] in parantheses)) {\n                    result[i] = ':COL_INDEX_' + (\"00\" + target_col).slice(-2) + ':' + result[i];\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Create a Search Tree from search query.\n     * @param query\n     * @param target_col optional target col to restrict the search on a specific col.\n     * @returns {*}\n     */\n    static fromQuery(query='', target_col=undefined) {\n        return SearchNode.searchArrayToTree(SearchNode.awesomeQuerySplitt0r(query, target_col));\n    }\n\n}\n\nmodule.exports = { SearchNode };\n\n/**\n * Check is value is in string. Support `\"` for exact and `\"\"` padding for exclusive match.\n * @param value string to be converted to regex and matched agains string.\n * @param string\n * @returns {boolean}\n */\nfunction check_value_in_string(value, string) {\n    // We support value to be `\n    //  * \"<inner>\"` for exact match.\n    //  * \"\"<inner>\"\" for exclusive match.\n\n    if (value.startsWith('\"\"') && value.endsWith('\"\"')) {\n        value = '^\\\\s*' + value.substr(2, (value.length - 4)) + '\\\\s*$';\n    } else {\n        // replace \" by \\b to allow for exact matches.\n        // In the input we escaped \" by \\\" so we would like to apply (?<!\\\\)\\\"\n        // since javascript does not allow negative look behinds we do\n        // something like ([^\\\\])(\\\") and replace the 2. group by \\b but keeping \\\" intact.\n        value = value.replace(/([^\\\\])?\\\"/g, \"$1\\\\b\");\n    }\n\n    const regex = new RegExp(value, \"i\");\n    return regex.test(string);\n\n}\n\n/**\n * Apply a search expression tree on row data.\n * @param tree\n * @param data\n * @param visible_columns\n * @returns {bool}\n */\nfunction evaluateSearchExpressionTree(tree, data, visible_columns) {\n    // Root node\n    if (tree === undefined) {\n        return true;\n    }\n\n    // Leaf node.\n    if (tree.left === false && tree.right === false) {\n        // First build the string to search.\n        let string = '';\n        // We have a specific target.\n        if (tree.col_target !== -1) {\n            string = data[tree.col_target];\n        } else {\n            // We search in all visible columns.\n            for (let i = 0; i < visible_columns.length; i++) {\n                if (visible_columns[i]) {\n                    string += data[i] + ' ';\n                }\n            }\n        }\n        const not_index = tree.value.indexOf(':NOT:');\n        if (not_index >= 0) { // Invert search on :NOT: keyword.\n            return !check_value_in_string(tree.value.substring(not_index + 5), string);\n        } else {\n            return check_value_in_string(tree.value, string);\n        }\n    }\n\n    // evaluate left tree\n    let left_sub = evaluateSearchExpressionTree(tree.left, data, visible_columns);\n\n    // evaluate right tree\n    let right_sub = evaluateSearchExpressionTree(tree.right, data, visible_columns);\n\n    // Apply operations\n    if (tree.value === ':AND:') {\n        return (left_sub && right_sub);\n    }\n\n    if (tree.value === ':OR:') {\n        return (left_sub || right_sub);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9kYXRhdGFibGVzLWFkdmFuY2VkLXNlYXJjaC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2pzL2RhdGF0YWJsZXMtYWR2YW5jZWQtc2VhcmNoLmpzPzM2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2VhcmNoIHF1ZXJ5IGdyYW1tYXIgZGVjbGFyYXRpb25zLlxuY29uc3Qgb3BlcmF0b3JzID0ge1wiOkFORDpcIjogMSwgXCI6T1I6XCI6IDF9O1xuY29uc3QgbGVmdEFzc29jID0ge1wiOkFORDpcIjogMSwgXCI6T1I6XCI6IDF9O1xuY29uc3QgcmlnaHRBc3NvYyA9IHt9O1xuY29uc3QgcGFyYW50aGVzZXMgPSB7XCIoXCI6IDEsIFwiKVwiOiAxfTtcbmNvbnN0IHByZWNlZGVuY2VPZiA9IHtcIjpBTkQ6XCI6IDMsIFwiOk9SOlwiOiAyfTtcblxuLyoqXG4gKiBTZWFyY2hOb2RlIHJlcHJlc2VudHMgb25lIG5vZGUgaW4gYSBzZWFyY2ggZXhwcmVzc2lvbiB1c2VkIHRvIGZpbHRlciB0aGUgcmVxdWlyZW1lbnRzIHRhYmxlLlxuICovXG5jbGFzcyBTZWFyY2hOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sX3RhcmdldCA9IC0xO1xuICAgICAgICB0aGlzLnVwZGF0ZV90YXJnZXQoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVfdGFyZ2V0KCkge1xuICAgICAgICBjb25zdCBjb2xfc3RyaW5nX2luZGV4ID0gdGhpcy52YWx1ZS5pbmRleE9mKCc6Q09MX0lOREVYXycpO1xuICAgICAgICBpZiAoY29sX3N0cmluZ19pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRfaW5kZXggPSBwYXJzZUludCh0aGlzLnZhbHVlLnN1YnN0cmluZyhjb2xfc3RyaW5nX2luZGV4ICsgMTEsIGNvbF9zdHJpbmdfaW5kZXggKyAxMykpO1xuICAgICAgICAgICAgaWYgKHRhcmdldF9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyaW5nKGNvbF9zdHJpbmdfaW5kZXggKyAxNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xfdGFyZ2V0ID0gdGFyZ2V0X2luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoZGF0YSwgdmlzaWJsZV9jb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZVNlYXJjaEV4cHJlc3Npb25UcmVlKHRoaXMsIGRhdGEsIHZpc2libGVfY29sdW1ucyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzX3NlYXJjaF9zdHJpbmcodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICEodG9rZW4gaW4gcGFyYW50aGVzZXMgfHwgdG9rZW4gaW4gb3BlcmF0b3JzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdG9fc3RyaW5nKHRyZWUpIHtcbiAgICAgICAgbGV0IHJlcHIgPSAnJztcbiAgICAgICAgaWYgKHRyZWUubGVmdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlcHIgKz0gU2VhcmNoTm9kZS50b19zdHJpbmcodHJlZS5sZWZ0KSArICcgJztcbiAgICAgICAgfVxuICAgICAgICByZXByICs9IHRyZWUudmFsdWU7XG4gICAgICAgIGlmICh0cmVlLnJpZ2h0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVwciArPSAnICcgKyBTZWFyY2hOb2RlLnRvX3N0cmluZyh0cmVlLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGVlayhhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2VhcmNoIGFycmF5IHRvIGEgYmluYXJ5IHNlYXJjaCB0cmVlIHVzaW5nIHNodW50aW5nIHlhcmQgYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSBhcnJheVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBzZWFyY2hBcnJheVRvVHJlZShhcnJheSkge1xuXG4gICAgICAgIGxldCBvdXRwdXRfdHJlZV9zdGFjayA9IFtdLCBvcF9zdGFjayA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7ICBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXJyYXlbaV07IC8vIGN1cnJlbnQgdG9rZW5cblxuICAgICAgICAgICAgLy8gSWYgdG9rZW4gaXMgYSBzZWFyY2ggc3RyaW5nLCBhZGQgaXQgdG8gdGhlIG91dHB1dF90cmVlX3N0YWNrIGFzIGEgc2luZ2xldG9uIHRyZWUuXG4gICAgICAgICAgICBpZiAoU2VhcmNoTm9kZS5pc19zZWFyY2hfc3RyaW5nKHRva2VuKSlcbiAgICAgICAgICAgICAgICBvdXRwdXRfdHJlZV9zdGFjay5wdXNoKG5ldyBTZWFyY2hOb2RlKHRva2VuKSk7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVuY291bnRlcmVkIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgICAgIHdoaWxlIChvcF9zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSBpcyBhbiBvcGVyYXRvciAocHJldl9vcCkgYXQgdGhlIHRvcCBvZiB0aGUgb3Bfc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldl9vcCA9IFNlYXJjaE5vZGUucGVlayhvcF9zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X29wIGluIG9wZXJhdG9ycyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRva2VuIGlzIGxlZnQgYXNzb2NpYXRpdmUgYW5kIHByZWNlZGVuY2UgPD0gdG8gdGhhdCBvZiBwcmV2X29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbiBpbiBsZWZ0QXNzb2MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZWNlZGVuY2VPZlt0b2tlbl0gPD0gcHJlY2VkZW5jZU9mW3ByZXZfb3BdKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciB0b2tlbiBpcyByaWdodCBhc3NvY2lhdGl2ZSBhbmQgaXRzIHByZWNlZGVuY2UgPCB0byB0aGF0IG9mIHByZXZfb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuIGluIHJpZ2h0QXNzb2MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZWNlZGVuY2VPZlt0b2tlbl0gPCBwcmVjZWRlbmNlT2ZbcHJldl9vcF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wIGxhc3QgdHdvIHN1YnRyZWVzIGFuZCBtYWtlIHRoZW0gY2hpbGRyZW4gb2YgYSBuZXcgc3VidHJlZSAod2l0aCBwcmV2X29wIGFzIHJvb3QpLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gb3V0cHV0X3RyZWVfc3RhY2sucG9wKCksIGxlZnQgPSBvdXRwdXRfdHJlZV9zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJfdHJlZSA9IG5ldyBTZWFyY2hOb2RlKG9wX3N0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl90cmVlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViX3RyZWUucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF90cmVlX3N0YWNrLnB1c2goc3ViX3RyZWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3Bfc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRva2VuIGlzIG9wZW5pbmcgcGFyZW50aGVzaXMsIGp1c3QgcHVzaCB0byB0aGUgb3Bfc3RhY2suXG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCIoXCIpXG4gICAgICAgICAgICAgICAgb3Bfc3RhY2sucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICAgIC8vIElmIHRva2VuIGlzIGNsb3NpbmcgcGFyZW50aGVzaXM6XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCIpXCIpIHtcblxuICAgICAgICAgICAgICAgIGxldCBoYXNfb3BlbmluZ19tYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBvcGVuaW5nIHBhcmFudGhlc2lzIGluIG9wX3N0YWNrLlxuICAgICAgICAgICAgICAgIHdoaWxlIChvcF9zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBvcF9zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzX29wZW5pbmdfbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnRpbCBtYXRjaCBwb3Agb3BlcmF0b3JzIG9mZiB0aGUgb3Bfc3RhY2sgYW5kIGNyZWF0ZSBhIG5ldyBzdWJ0cmVlIHdpdGggb3BlcmF0b3IgYXMgcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByaWdodCA9IG91dHB1dF90cmVlX3N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBvdXRwdXRfdHJlZV9zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJfdHJlZSA9IG5ldyBTZWFyY2hOb2RlKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yl90cmVlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViX3RyZWUucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF90cmVlX3N0YWNrLnB1c2goc3ViX3RyZWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzX29wZW5pbmdfbWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3I6IHBhcmVudGhlc2VzIG1pc21hdGNoLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB0aHJvdyBcIkVycm9yOiBUb2tlbiB1bmtub3duOiBcIiArIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gbW9yZSB0b2tlbnMgaW4gaW5wdXQgYnV0IG9wZXJhdG9yIHRva2VucyBpbiB0aGUgb3Bfc3RhY2s6XG4gICAgICAgIHdoaWxlIChvcF9zdGFjay5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY29uc3Qgb3AgPSBvcF9zdGFjay5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKG9wID09PSBcIihcIiB8fCBvcCA9PT0gXCIpXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvcjogUGFyZW50aGVzZXMgbWlzbWF0Y2guXCI7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgc3VidHJlZSB3aXRoIG9wIGFzIHJvb3QuXG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBvdXRwdXRfdHJlZV9zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gb3V0cHV0X3RyZWVfc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgc3ViX3RyZWUgPSBuZXcgU2VhcmNoTm9kZShvcCk7XG4gICAgICAgICAgICBzdWJfdHJlZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHN1Yl90cmVlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICBvdXRwdXRfdHJlZV9zdGFjay5wdXNoKHN1Yl90cmVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtcHR5IHN0YWNrID0+IGNyZWF0ZSBlbXB0eSBkdW1teSBOb2RlLlxuICAgICAgICBpZiAob3V0cHV0X3RyZWVfc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBvdXRwdXRfdHJlZV9zdGFjay5wdXNoKG5ldyBTZWFyY2hOb2RlKCcnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbGFzdCByZW1haW5pbmcgbm9kZSBzaG91bGQgYmUgdGhlIHJvb3Qgb2Ygb3VyIGNvbXBsZXRlIHNlYXJjaCB0cmVlLlxuICAgICAgICByZXR1cm4gb3V0cHV0X3RyZWVfc3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgc2VhcmNoIHF1ZXJ5IGludG8gYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGlzIG9uZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcXVlcnlcbiAgICAgKiBAcGFyYW0gdGFyZ2V0X2NvbCBvcHRpb25hbCB0YXJnZXQgY29sIHRvIHJlc3RyaWN0IHRoZSBzZWFyY2ggb24gYSBzcGVjaWZpYyBjb2wuXG4gICAgICogQHJldHVybnMgeyp8c3RyaW5nW119XG4gICAgICovXG4gICAgc3RhdGljIGF3ZXNvbWVRdWVyeVNwbGl0dDByKHF1ZXJ5LCB0YXJnZXRfY29sPXVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTcGxpdCBieSA6QU5EOlxuICAgICAgICBsZXQgcmVzdWx0ID0gcXVlcnkuc3BsaXQoLyg6T1I6fDpBTkQ6fFxcKHxcXCkpL2cpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKFN0cmluZyk7IC8vIFJlbW92ZSBlbXB0eSBlbGVtZW50cy5cbiAgICAgICAgLy8gSWYgdGhlIHJlc3VsdGluZyB0cmVlIHNob3VsZCBiZSByZXN0cmljdGVkIHRvIGEgY29sLi5cbiAgICAgICAgaWYgKHRhcmdldF9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7ICBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgOkNPTF9JTkRFWF88dGFyZ2V0X2NvbD46IHRvIGVhY2ggc2VhcmNoIHN0cmluZyAobm90IGEgb3BlcmF0b3Igb3IgcGFyZW50aGVzaXMpLlxuICAgICAgICAgICAgICAgIGlmICghKHJlc3VsdFtpXSBpbiBvcGVyYXRvcnMgfHwgcmVzdWx0W2ldIGluIHBhcmFudGhlc2VzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnOkNPTF9JTkRFWF8nICsgKFwiMDBcIiArIHRhcmdldF9jb2wpLnNsaWNlKC0yKSArICc6JyArIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTZWFyY2ggVHJlZSBmcm9tIHNlYXJjaCBxdWVyeS5cbiAgICAgKiBAcGFyYW0gcXVlcnlcbiAgICAgKiBAcGFyYW0gdGFyZ2V0X2NvbCBvcHRpb25hbCB0YXJnZXQgY29sIHRvIHJlc3RyaWN0IHRoZSBzZWFyY2ggb24gYSBzcGVjaWZpYyBjb2wuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21RdWVyeShxdWVyeT0nJywgdGFyZ2V0X2NvbD11bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFNlYXJjaE5vZGUuc2VhcmNoQXJyYXlUb1RyZWUoU2VhcmNoTm9kZS5hd2Vzb21lUXVlcnlTcGxpdHQwcihxdWVyeSwgdGFyZ2V0X2NvbCkpO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgU2VhcmNoTm9kZSB9O1xuXG4vKipcbiAqIENoZWNrIGlzIHZhbHVlIGlzIGluIHN0cmluZy4gU3VwcG9ydCBgXCJgIGZvciBleGFjdCBhbmQgYFwiXCJgIHBhZGRpbmcgZm9yIGV4Y2x1c2l2ZSBtYXRjaC5cbiAqIEBwYXJhbSB2YWx1ZSBzdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHJlZ2V4IGFuZCBtYXRjaGVkIGFnYWlucyBzdHJpbmcuXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tfdmFsdWVfaW5fc3RyaW5nKHZhbHVlLCBzdHJpbmcpIHtcbiAgICAvLyBXZSBzdXBwb3J0IHZhbHVlIHRvIGJlIGBcbiAgICAvLyAgKiBcIjxpbm5lcj5cImAgZm9yIGV4YWN0IG1hdGNoLlxuICAgIC8vICAqIFwiXCI8aW5uZXI+XCJcIiBmb3IgZXhjbHVzaXZlIG1hdGNoLlxuXG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiXCInKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXCJcIicpKSB7XG4gICAgICAgIHZhbHVlID0gJ15cXFxccyonICsgdmFsdWUuc3Vic3RyKDIsICh2YWx1ZS5sZW5ndGggLSA0KSkgKyAnXFxcXHMqJCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVwbGFjZSBcIiBieSBcXGIgdG8gYWxsb3cgZm9yIGV4YWN0IG1hdGNoZXMuXG4gICAgICAgIC8vIEluIHRoZSBpbnB1dCB3ZSBlc2NhcGVkIFwiIGJ5IFxcXCIgc28gd2Ugd291bGQgbGlrZSB0byBhcHBseSAoPzwhXFxcXClcXFwiXG4gICAgICAgIC8vIHNpbmNlIGphdmFzY3JpcHQgZG9lcyBub3QgYWxsb3cgbmVnYXRpdmUgbG9vayBiZWhpbmRzIHdlIGRvXG4gICAgICAgIC8vIHNvbWV0aGluZyBsaWtlIChbXlxcXFxdKShcXFwiKSBhbmQgcmVwbGFjZSB0aGUgMi4gZ3JvdXAgYnkgXFxiIGJ1dCBrZWVwaW5nIFxcXCIgaW50YWN0LlxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhbXlxcXFxdKT9cXFwiL2csIFwiJDFcXFxcYlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAodmFsdWUsIFwiaVwiKTtcbiAgICByZXR1cm4gcmVnZXgudGVzdChzdHJpbmcpO1xuXG59XG5cbi8qKlxuICogQXBwbHkgYSBzZWFyY2ggZXhwcmVzc2lvbiB0cmVlIG9uIHJvdyBkYXRhLlxuICogQHBhcmFtIHRyZWVcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gdmlzaWJsZV9jb2x1bW5zXG4gKiBAcmV0dXJucyB7Ym9vbH1cbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVTZWFyY2hFeHByZXNzaW9uVHJlZSh0cmVlLCBkYXRhLCB2aXNpYmxlX2NvbHVtbnMpIHtcbiAgICAvLyBSb290IG5vZGVcbiAgICBpZiAodHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExlYWYgbm9kZS5cbiAgICBpZiAodHJlZS5sZWZ0ID09PSBmYWxzZSAmJiB0cmVlLnJpZ2h0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBGaXJzdCBidWlsZCB0aGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgICAgbGV0IHN0cmluZyA9ICcnO1xuICAgICAgICAvLyBXZSBoYXZlIGEgc3BlY2lmaWMgdGFyZ2V0LlxuICAgICAgICBpZiAodHJlZS5jb2xfdGFyZ2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgc3RyaW5nID0gZGF0YVt0cmVlLmNvbF90YXJnZXRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2Ugc2VhcmNoIGluIGFsbCB2aXNpYmxlIGNvbHVtbnMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2libGVfY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlX2NvbHVtbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGRhdGFbaV0gKyAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdF9pbmRleCA9IHRyZWUudmFsdWUuaW5kZXhPZignOk5PVDonKTtcbiAgICAgICAgaWYgKG5vdF9pbmRleCA+PSAwKSB7IC8vIEludmVydCBzZWFyY2ggb24gOk5PVDoga2V5d29yZC5cbiAgICAgICAgICAgIHJldHVybiAhY2hlY2tfdmFsdWVfaW5fc3RyaW5nKHRyZWUudmFsdWUuc3Vic3RyaW5nKG5vdF9pbmRleCArIDUpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrX3ZhbHVlX2luX3N0cmluZyh0cmVlLnZhbHVlLCBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXZhbHVhdGUgbGVmdCB0cmVlXG4gICAgbGV0IGxlZnRfc3ViID0gZXZhbHVhdGVTZWFyY2hFeHByZXNzaW9uVHJlZSh0cmVlLmxlZnQsIGRhdGEsIHZpc2libGVfY29sdW1ucyk7XG5cbiAgICAvLyBldmFsdWF0ZSByaWdodCB0cmVlXG4gICAgbGV0IHJpZ2h0X3N1YiA9IGV2YWx1YXRlU2VhcmNoRXhwcmVzc2lvblRyZWUodHJlZS5yaWdodCwgZGF0YSwgdmlzaWJsZV9jb2x1bW5zKTtcblxuICAgIC8vIEFwcGx5IG9wZXJhdGlvbnNcbiAgICBpZiAodHJlZS52YWx1ZSA9PT0gJzpBTkQ6Jykge1xuICAgICAgICByZXR1cm4gKGxlZnRfc3ViICYmIHJpZ2h0X3N1Yik7XG4gICAgfVxuXG4gICAgaWYgKHRyZWUudmFsdWUgPT09ICc6T1I6Jykge1xuICAgICAgICByZXR1cm4gKGxlZnRfc3ViIHx8IHJpZ2h0X3N1Yik7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/datatables-advanced-search.js\n");

/***/ }),

/***/ "./js/requirements.js":
/*!****************************!*\
  !*** ./js/requirements.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function($) {__webpack_require__(/*! gasparesganga-jquery-loading-overlay */ \"./node_modules/gasparesganga-jquery-loading-overlay/src/loadingoverlay.js\");\r\n__webpack_require__(/*! bootstrap */ \"./node_modules/bootstrap/dist/js/bootstrap.js\");\r\n__webpack_require__(/*! bootstrap-confirmation2 */ \"./node_modules/bootstrap-confirmation2/dist/bootstrap-confirmation.js\");\r\n__webpack_require__(/*! datatables.net-bs4 */ \"./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js\");\r\n__webpack_require__(/*! datatables.net-select */ \"./node_modules/datatables.net-select/js/dataTables.select.js\");\r\n__webpack_require__(/*! jquery-ui/ui/widgets/autocomplete */ \"./node_modules/jquery-ui/ui/widgets/autocomplete.js\");\r\n__webpack_require__(/*! jquery-ui/ui/effects/effect-highlight */ \"./node_modules/jquery-ui/ui/effects/effect-highlight.js\");\r\n__webpack_require__(/*! ./bootstrap-tokenfield.js */ \"./js/bootstrap-tokenfield.js\");\r\n\r\n// Globals\r\nconst { SearchNode } = __webpack_require__(/*! ./datatables-advanced-search.js */ \"./js/datatables-advanced-search.js\");\r\nlet Fuse = __webpack_require__(/*! fuse.js */ \"./node_modules/fuse.js/dist/fuse.js\");\r\nlet { Textcomplete, Textarea } = __webpack_require__(/*! textcomplete */ \"./node_modules/textcomplete/lib/index.js\");\r\nlet fuse = new Fuse([], {});\r\n\r\nlet available_tags = ['', 'has_formalization'];\r\nlet available_status = ['', 'Todo', 'Review', 'Done'];\r\nlet available_types = [''];\r\nlet available_vars = [''];\r\nlet visible_columns = [true, true, true, true, true, true];\r\nlet filter_search_array = [];\r\nlet get_query = JSON.parse(search_query); // search_query is set in index.html\r\nlet tag_colors = {};\r\nlet type_inference_errors = [];\r\nlet req_search_string = sessionStorage.getItem('req_search_string');\r\nlet filter_status_string = sessionStorage.getItem('filter_status_string');\r\nlet filter_tag_string = sessionStorage.getItem('filter_tag_string');\r\nlet filter_type_string = sessionStorage.getItem('filter_type_string');\r\nlet search_tree = undefined;\r\nlet filter_tree = undefined;\r\n\r\n\r\n/**\r\n * Update the search expression tree.\r\n */\r\nfunction update_search() {\r\n    req_search_string = $('#search_bar').val().trim();\r\n    sessionStorage.setItem('req_search_string', req_search_string);\r\n    search_tree = SearchNode.fromQuery(req_search_string);\r\n}\r\n\r\n/**\r\n * Update the filter search tree used to filter the table by the values from the Filter tab.\r\n */\r\nfunction update_filter() {\r\n    filter_search_array = [];\r\n    function pad_with_parantheses(array) {\r\n        return [\"(\"].concat(array, [\")\"]);\r\n    }\r\n    function add_query(array, query, target) {\r\n        if (query.length > 0) {\r\n            if (array.length > 0) {\r\n                array = array.concat([\":AND:\"]);\r\n            }\r\n            array = array.concat(pad_with_parantheses(SearchNode.awesomeQuerySplitt0r(query, target)));\r\n        }\r\n        return array\r\n    }\r\n    filter_status_string = $('#status-filter-input').val();\r\n    filter_tag_string = $('#tag-filter-input').val();\r\n    filter_type_string = $('#type-filter-input').val();\r\n\r\n    sessionStorage.setItem('filter_status_string', filter_status_string);\r\n    sessionStorage.setItem('filter_tag_string', filter_tag_string);\r\n    sessionStorage.setItem('filter_type_string', filter_type_string);\r\n\r\n    filter_search_array = add_query(filter_search_array, filter_type_string, 4);\r\n    filter_search_array = add_query(filter_search_array, filter_tag_string, 5);\r\n    filter_search_array = add_query(filter_search_array, filter_status_string, 6);\r\n\r\n    filter_tree = SearchNode.searchArrayToTree(filter_search_array);\r\n}\r\n\r\n\r\nfunction evaluate_search(data){\r\n    return search_tree.evaluate(data, visible_columns) && filter_tree.evaluate(data, visible_columns);\r\n}\r\n\r\n/**\r\n * Apply a URL search query to the requirements table.\r\n * @param requirements_table\r\n * @param get_query\r\n */\r\nfunction process_url_query(get_query) {\r\n    // Apply search if we have one.\r\n    if (get_query.q.length > 0) {\r\n        function pad(num) {\r\n            let s = \"00\" + num;\r\n            return s.substr(s.length-2);\r\n        }\r\n        // Clear filters.\r\n        $('#status-filter-input').val('');\r\n        $('#tag-filter-input').val('');\r\n        $('#type-filter-input').val('');\r\n\r\n        // Set search for requirement ID\r\n        const s = ':COL_INDEX_' + pad(get_query.col).toString() + ':' + get_query.q;\r\n        $('#search_bar').val(s);\r\n    }\r\n}\r\n\r\n/**\r\n * Stores the active (in modal) requirement and updates the row in the requirements table.\r\n * @param {DataTable} requirements_table\r\n */\r\nfunction store_requirement(requirements_table) {\r\n    let requirement_modal_content = $('.modal-content');\r\n    requirement_modal_content.LoadingOverlay('show');\r\n\r\n    const req_id = $('#requirement_id').val();\r\n    const req_tags = $('#requirement_tag_field').val();\r\n    const req_status = $('#requirement_status').val();\r\n    const updated_formalization = $('#requirement_modal').data('updated_formalization');\r\n    const associated_row_id = parseInt($('#modal_associated_row_index').val());\r\n\r\n    // Fetch the formalizations\r\n    let formalizations = {};\r\n    $('.formalization_card').each(function ( index ) {\r\n        // Scope and Pattern\r\n        let formalization = {};\r\n        formalization['id'] = $(this).attr('title');\r\n        $( this ).find( 'select').each( function () {\r\n            if ($( this ).hasClass('scope_selector')) {\r\n                formalization['scope'] = $( this ).val();\r\n            }\r\n            if ($( this ).hasClass('pattern_selector')) {\r\n                formalization['pattern'] = $( this ).val();\r\n            }\r\n        });\r\n\r\n        // Expressions\r\n        formalization['expression_mapping'] = {};\r\n        $( this ).find( \"textarea.reqirement-variable\" ).each(function () {\r\n            if ($(this).attr('title') !== '')\r\n            formalization['expression_mapping'][$(this).attr('title')] = $(this).val();\r\n        });\r\n\r\n        formalizations[formalization['id']] = formalization;\r\n    });\r\n\r\n    // Store the requirement.\r\n    $.post( \"api/req/update\",\r\n        {\r\n            id: req_id,\r\n            row_idx: associated_row_id,\r\n            update_formalization: updated_formalization,\r\n            tags: req_tags,\r\n            status: req_status,\r\n            formalizations: JSON.stringify(formalizations)\r\n        },\r\n        // Update requirements table on success or show an error message.\r\n        function( data ) {\r\n            requirement_modal_content.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                requirements_table.row(associated_row_id).data(data);\r\n                $('#requirement_modal').data('unsaved_changes', false).modal('hide');\r\n            }\r\n    }).done(function () {\r\n        update_logs();\r\n    });\r\n}\r\n\r\n\r\n/***\r\n *\r\n * @param requirements_table\r\n * @returns {Array} User selected requirement ids.\r\n */\r\nfunction get_selected_requirement_ids(requirements_table) {\r\n    let selected_ids = [];\r\n    requirements_table.rows( {selected:true} ).every( function () {\r\n        let d = this.data();\r\n        selected_ids.push(d['id']);\r\n    } );\r\n\r\n    return selected_ids\r\n}\r\n\r\n\r\nfunction apply_multi_edit(requirements_table) {\r\n    let page = $('body');\r\n    page.LoadingOverlay('show');\r\n    let add_tag = $('#multi-add-tag-input').val().trim();\r\n    let remove_tag = $('#multi-remove-tag-input').val().trim();\r\n    let set_status = $('#multi-set-status-input').val().trim();\r\n    let selected_ids = get_selected_requirement_ids(requirements_table);\r\n\r\n    $.post( \"api/req/multi_update\",\r\n        {\r\n            add_tag: add_tag,\r\n            remove_tag: remove_tag,\r\n            set_status: set_status,\r\n            selected_ids: JSON.stringify(selected_ids)\r\n        },\r\n        // Update requirements table on success or show an error message.\r\n        function( data ) {\r\n            page.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                location.reload();\r\n            }\r\n    });\r\n}\r\n\r\n\r\nfunction add_top_guess_to_selected_requirements(requirements_table) {\r\n    let page = $('body');\r\n    page.LoadingOverlay('show');\r\n    let selected_ids = get_selected_requirement_ids(requirements_table);\r\n    let insert_mode = $('#top_guess_append_mode').val();\r\n\r\n    $.post( \"api/req/multi_add_top_guess\",\r\n        {\r\n            selected_ids: JSON.stringify(selected_ids),\r\n            insert_mode: insert_mode\r\n        },\r\n        // Update requirements table on success or show an error message.\r\n        function( data ) {\r\n            page.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                location.reload();\r\n            }\r\n    });\r\n}\r\n\r\n/**\r\n * Enable/disable the active variables (P, Q, R, ...) in the requirement modal based on scope and pattern.\r\n */\r\nfunction update_vars() {\r\n    $('.requirement_var_group').each(function () {\r\n        $( this ).hide();\r\n        $( this ).removeClass('type-error');\r\n    });\r\n\r\n    $('.formalization_card').each(function ( index ) {\r\n        // Fetch attributes\r\n        const formalization_id = $(this).attr('title');\r\n        const selected_scope = $('#requirement_scope' + formalization_id).val();\r\n        const selected_pattern = $('#requirement_pattern' + formalization_id).val();\r\n        let header = $('#formalization_heading' + formalization_id);\r\n        let var_p = $('#requirement_var_group_p' + formalization_id);\r\n        let var_q = $('#requirement_var_group_q' + formalization_id);\r\n        let var_r = $('#requirement_var_group_r' + formalization_id);\r\n        let var_s = $('#requirement_var_group_s' + formalization_id);\r\n        let var_t = $('#requirement_var_group_t' + formalization_id);\r\n        let var_u = $('#requirement_var_group_u' + formalization_id);\r\n\r\n        // Set the red boxes for type inference failed expressions.\r\n        if (formalization_id in type_inference_errors) {\r\n            for (let i = 0; i < type_inference_errors[formalization_id].length; i++) {\r\n                $('#formalization_var_' + type_inference_errors[formalization_id][i] + formalization_id)\r\n                    .addClass('type-error');\r\n                header.addClass('type-error-head');\r\n            }\r\n        } else {\r\n            header.removeClass('type-error-head');\r\n        }\r\n\r\n        switch(selected_scope) {\r\n            case 'BEFORE':\r\n            case 'AFTER':\r\n                var_p.show();\r\n                break;\r\n            case 'BETWEEN':\r\n            case 'AFTER_UNTIL':\r\n                var_p.show();\r\n                var_q.show();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        switch(selected_pattern) {\r\n            case 'Absence':\r\n            case 'Universality':\r\n            case 'Existence':\r\n            case 'BoundedExistence':\r\n                var_r.show();\r\n                break;\r\n            case 'Invariant':\r\n            case 'Precedence':\r\n            case 'Response':\r\n            case 'MinDuration':\r\n            case 'MaxDuration':\r\n            case 'BoundedRecurrence':\r\n                var_r.show();\r\n                var_s.show();\r\n                break;\r\n            case 'PrecedenceChain1-2':\r\n            case 'PrecedenceChain2-1':\r\n            case 'ResponseChain1-2':\r\n            case 'ResponseChain2-1':\r\n            case 'BoundedResponse':\r\n            case 'BoundedInvariance':\r\n            case 'TimeConstrainedInvariant':\r\n                var_r.show();\r\n                var_s.show();\r\n                var_t.show();\r\n                break;\r\n            case 'ConstrainedChain':\r\n            case 'TimeConstrainedMinDuration':\r\n            case 'ConstrainedTimedExistence':\r\n                var_r.show();\r\n                var_s.show();\r\n                var_t.show();\r\n                var_u.show();\r\n                break;\r\n            case 'NotFormalizable':\r\n                var_p.hide();\r\n                var_q.hide();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Updates the formalization textarea based on the selected scope and expressions in P, Q, R, S, T.\r\n */\r\nfunction update_formalization() {\r\n    $('.formalization_card').each(function ( index ) {\r\n        // Fetch attributes\r\n        const formalization_id = $(this).attr('title');\r\n\r\n        let formalization = '';\r\n        const selected_scope = $('#requirement_scope' + formalization_id).find('option:selected').text().replace(/\\s\\s+/g, ' ');\r\n        const selected_pattern = $('#requirement_pattern' + formalization_id).find('option:selected').text().replace(/\\s\\s+/g, ' ');\r\n\r\n        if (selected_scope !== 'None' && selected_pattern !== 'None') {\r\n            formalization = selected_scope + ', ' + selected_pattern + '.';\r\n        }\r\n\r\n        // Update formalization with variables.\r\n        let var_p = $('#formalization_var_p' + formalization_id).val();\r\n        let var_q = $('#formalization_var_q' + formalization_id).val();\r\n        let var_r = $('#formalization_var_r' + formalization_id).val();\r\n        let var_s = $('#formalization_var_s' + formalization_id).val();\r\n        let var_t = $('#formalization_var_t' + formalization_id).val();\r\n        let var_u = $('#formalization_var_u' + formalization_id).val();\r\n\r\n        if (var_p.length > 0) {\r\n            formalization = formalization.replace(/{P}/g, var_p);\r\n        }\r\n        if (var_q.length > 0) {\r\n            formalization = formalization.replace(/{Q}/g, var_q);\r\n        }\r\n        if (var_r.length > 0) {\r\n            formalization = formalization.replace(/{R}/g, var_r);\r\n        }\r\n        if (var_s.length > 0) {\r\n            formalization = formalization.replace(/{S}/g, var_s);\r\n        }\r\n        if (var_t.length > 0) {\r\n            formalization = formalization.replace(/{T}/g, var_t);\r\n        }\r\n        if (var_u.length > 0) {\r\n            formalization = formalization.replace(/{U}/g, var_u);\r\n        }\r\n\r\n        $('#current_formalization_textarea' + formalization_id).val(formalization);\r\n    });\r\n    $('#requirement_modal').data({\r\n        'unsaved_changes': true,\r\n        'updated_formalization': true\r\n    });\r\n}\r\n\r\n\r\nfunction add_formalization() {\r\n    // Request a new Formalization. And add its edit elements to the modal.\r\n    let requirement_modal_content = $('.modal-content');\r\n    requirement_modal_content.LoadingOverlay('show');\r\n\r\n    const req_id = $('#requirement_id').val();\r\n    $.post( \"api/req/new_formalization\",\r\n        {\r\n            id: req_id\r\n        },\r\n        function( data ) {\r\n            requirement_modal_content.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                $('#formalization_accordion').append(data['html']);\r\n            }\r\n    }).done(function () {\r\n        update_vars();\r\n        update_formalization();\r\n        bind_expression_buttons();\r\n        bind_var_autocomplete();\r\n        update_logs();\r\n    });\r\n}\r\n\r\n\r\nfunction add_formalization_from_guess(scope, pattern, mapping) {\r\n    // Request a new Formalization. And add its edit elements to the modal.\r\n    let requirement_modal_content = $('.modal-content');\r\n    requirement_modal_content.LoadingOverlay('show');\r\n\r\n    let requirement_id = $('#requirement_id').val();\r\n    $.post( \"api/req/add_formalization_from_guess\",\r\n        {\r\n            requirement_id: requirement_id,\r\n            scope: scope,\r\n            pattern: pattern,\r\n            mapping: JSON.stringify(mapping)\r\n        },\r\n        function( data ) {\r\n            requirement_modal_content.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                $('#formalization_accordion').append(data['html']);\r\n            }\r\n    }).done(function () {\r\n        update_vars();\r\n        update_formalization();\r\n        bind_expression_buttons();\r\n        bind_var_autocomplete();\r\n        update_logs();\r\n    });\r\n}\r\n\r\n\r\nfunction delete_formalization(formal_id) {\r\n    let requirement_modal_content = $('.modal-content');\r\n    requirement_modal_content.LoadingOverlay('show');\r\n    const req_id = $('#requirement_id').val();\r\n    $.post( \"api/req/del_formalization\",\r\n        {\r\n            requirement_id: req_id,\r\n            formalization_id: formal_id\r\n        },\r\n        function( data ) {\r\n            requirement_modal_content.LoadingOverlay('hide', true);\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg']);\r\n            } else {\r\n                $('#formalization_accordion').html(data['html']);\r\n            }\r\n    }).done(function () {\r\n        update_vars();\r\n        update_formalization();\r\n        bind_expression_buttons();\r\n        bind_var_autocomplete();\r\n        update_logs();\r\n    });\r\n}\r\n\r\n\r\nfunction bind_expression_buttons() {\r\n    $('.formalization_selector').change(function () {\r\n        update_vars();\r\n        update_formalization();\r\n    });\r\n    $('.reqirement-variable, .req_var_type').change(function () {\r\n        update_formalization();\r\n    });\r\n    $('.delete_formalization').confirmation({\r\n      rootSelector: '.delete_formalization'\r\n    }).click(function () {\r\n        delete_formalization( $(this).attr('name') );\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Reload fuse the fuzzy search provider used for autocomplete.\r\n * fuse will be reloaded with available_vars.\r\n */\r\nfunction update_fuse() {\r\n    let options = {\r\n      shouldSort: true,\r\n      threshold: 0.6,\r\n      location: 0,\r\n      distance: 100,\r\n      maxPatternLength: 12,\r\n      minMatchCharLength: 1,\r\n      keys: undefined\r\n    };\r\n\r\n    fuse = new Fuse(available_vars, options);\r\n}\r\n\r\n\r\n/**\r\n * Search term in the fuse fuzzy search provider.\r\n * Fuse is initialized with the available_vars.\r\n * @param term\r\n */\r\nfunction fuzzy_search(term) {\r\n    return fuse.search(term);\r\n}\r\n\r\n\r\n/**\r\n * Bind autocomplete trigger to formalization input fields.\r\n * Implement autocomplete.\r\n *\r\n */\r\nfunction bind_var_autocomplete() {\r\n    $( \".reqirement-variable\" ).each(function ( index ) {\r\n        let editor = new Textarea(this);\r\n        let textcomplete = new Textcomplete(editor, {\r\n          dropdown: {\r\n              maxCount: 10\r\n          }\r\n        });\r\n        textcomplete.register([{\r\n          match: /(^|\\s|[!=&\\|>]+)(\\w+)$/,\r\n          search: function (term, callback) {\r\n              include_elems = fuzzy_search(term);\r\n\r\n              result = [];\r\n              for (let i = 0; i < Math.min(10, include_elems.length); i++) {\r\n                    result.push(available_vars[include_elems[i]]);\r\n              }\r\n              callback(result);\r\n          },\r\n          replace: function (value) {\r\n            return '$1' + value + ' ';\r\n          }\r\n        }]);\r\n        // Close dropdown if textarea is no longer focused.\r\n        $(this).on('blur click', function (e) {\r\n            textcomplete.dropdown.deactivate();\r\n            e.preventDefault();\r\n        })\r\n    })\r\n}\r\n\r\n\r\nfunction prevent_double_token_insert() {\r\n    $('#requirement_tag_field').on('tokenfield:createtoken', function (event) {\r\n        let existingTokens = $(this).tokenfield('getTokens');\r\n        $.each(existingTokens, function(index, token) {\r\n            if (token.value === event.attrs.value)\r\n                event.preventDefault();\r\n        });\r\n    });\r\n}\r\n\r\n\r\nfunction load_requirement(row_idx) {\r\n    if (row_idx === -1) {\r\n        alert(\"Requirement not found.\");\r\n        return\r\n    }\r\n\r\n    // Get row data\r\n    let data = $('#requirements_table').DataTable().row(row_idx).data();\r\n\r\n    // Prepare requirement Modal\r\n    let requirement_modal_content = $('.modal-content');\r\n    $('#requirement_modal').modal('show');\r\n    requirement_modal_content.LoadingOverlay('show');\r\n    $('#formalization_accordion').html('');\r\n\r\n    // Set available tags.\r\n    $('#requirement_tag_field').data('bs.tokenfield').$input.autocomplete({source: available_tags});\r\n\r\n    // Get the requirement data and set the modal.\r\n    $.get( \"api/req/get\", { id: data['id'], row_idx: row_idx }, function (data) {\r\n        // Meta information\r\n        $('#requirement_id').val(data.id);\r\n        $('#modal_associated_row_index').val(row_idx);\r\n        available_vars = data.available_vars;\r\n        type_inference_errors = data.type_inference_errors;\r\n        update_fuse();\r\n\r\n        // Visible information\r\n        $('#requirement_modal_title').html(data.id + ': ' + data.type);\r\n        $('#description_textarea').text(data.desc);\r\n        $('#add_guess_description').text(data.desc);\r\n\r\n        // Parse the formalizations\r\n        $('#formalization_accordion').html(data.formalizations_html);\r\n\r\n        $('#requirement_scope').val(data.scope);\r\n        $('#requirement_pattern').val(data.pattern);\r\n\r\n        // Set the tags\r\n        $('#requirement_tag_field').tokenfield('setTokens', data.tags);\r\n        $('#requirement_status').val(data.status);\r\n\r\n        // Set csv_data\r\n        let csv_row_content = $('#csv_content_accordion');\r\n        csv_row_content.html('');\r\n        csv_row_content.collapse('hide');\r\n        let csv_data = data.csv_data;\r\n        for(const key in csv_data){\r\n            if (csv_data.hasOwnProperty(key)){\r\n                const value = csv_data[key];\r\n                csv_row_content.append('<p><strong>' + key + ':</strong>' + value + '</p>');\r\n            }\r\n        }\r\n        if (data.success === false) {\r\n            alert('Could Not load the Requirement: ' + data.errormsg);\r\n        }\r\n    } ).done(function () {\r\n        // Update visible Vars.\r\n        update_vars();\r\n        // Handle autocompletion for variables.\r\n        bind_var_autocomplete();\r\n        // Update available vars based on the selection of requirement and pattern.\r\n        bind_expression_buttons();\r\n        // Prevent inserting a token twice on enter\r\n        prevent_double_token_insert();\r\n        $('#requirement_modal').data({\r\n            'unsaved_changes': false,\r\n            'updated_formalization': false\r\n        });\r\n        requirement_modal_content.LoadingOverlay('hide', true);\r\n    });\r\n}\r\n\r\n/**\r\n * Bind the Links to open a requirement modal.\r\n * Implement Behaviour:\r\n *  * Load and show requirement data\r\n * @param requirements_table\r\n */\r\nfunction bind_requirement_id_to_modals(requirements_table) {\r\n    // Add listener for clicks on the Rows.\r\n    $('#requirements_table').find('tbody').on('click', 'a', function (event) {\r\n        // prevent body to be scrolled to the top.\r\n        event.preventDefault();\r\n        let row_idx = requirements_table.row($(event.target).parent()).index();\r\n        load_requirement(row_idx);\r\n    } );\r\n}\r\n\r\n\r\n/**\r\n * Update the color of the column toggle buttons.\r\n * Column visible -> Button blue (btn-info).\r\n * Column not visible -> Button grey (btn-secondary).\r\n * Update visible_columns\r\n */\r\nfunction update_visible_columns_information() {\r\n    let requirements_table = $('#requirements_table').DataTable();\r\n    let new_visible_columns = [];\r\n    $.each(requirements_table.columns().visible(), function(key, value) {\r\n        if(value === false){\r\n            $('#col_toggle_button_' + key).removeClass('btn-info').addClass('btn-secondary');\r\n            new_visible_columns.push(false);\r\n        } else {\r\n            $('#col_toggle_button_' + key).removeClass('btn-secondary').addClass('btn-info');\r\n            new_visible_columns.push(true);\r\n        }\r\n    });\r\n    visible_columns = new_visible_columns;\r\n}\r\n\r\n/**\r\n * Bind the requirements table manipulators to the table.\r\n * Initialize manipulators behaviour.\r\n * @param requirements_table The requirements table\r\n */\r\nfunction init_datatable_manipulators(requirements_table) {\r\n    // Headers extension: Add index to address in search.\r\n    requirements_table.columns().every( function ( index ) {\r\n        if (index > 0) requirements_table.column( index ).header().append(' (' + index + ')');\r\n    } );\r\n\r\n    // Save button\r\n    $('#save_requirement_modal').click(function () {\r\n        store_requirement(requirements_table);\r\n    });\r\n\r\n    // Table Search related stuff.\r\n    // Bind big custom searchbar to search the table.\r\n    $('#search_bar').keypress(function(e) {\r\n        if(e.which === 13) { // Search on enter.\r\n            update_search();\r\n            requirements_table.draw();\r\n        }\r\n    });\r\n\r\n    // Table filters.\r\n    $('#type-filter-input').autocomplete({\r\n        minLength: 0,\r\n        source: available_types,\r\n        delay: 100\r\n    });\r\n\r\n    $('#status-filter-input').autocomplete({\r\n        minLength: 0,\r\n        source: available_status,\r\n        delay: 100\r\n    });\r\n\r\n    $('#tag-filter-input').autocomplete({\r\n        minLength: 0,\r\n        source: available_tags,\r\n        delay: 100\r\n    });\r\n\r\n    $('#tag-filter-input, #status-filter-input, #type-filter-input')\r\n        .on('focus', function() { $(this).keydown(); })\r\n        .on('keypress', function (e) {\r\n            if (e.which === 13) { // Search on Enter.\r\n                update_filter();\r\n                requirements_table.draw();\r\n            }\r\n        });\r\n\r\n    $('#table-filter-toggle').click(function () {\r\n        $('#tag-filter-input').autocomplete({source: available_tags});\r\n        $('#type-filter-input').autocomplete({source: available_types});\r\n    });\r\n\r\n    // Clear all applied searches.\r\n    $('.clear-all-filters').click(function () {\r\n        $('#status-filter-input').val('').effect(\"highlight\", {color: 'green'}, 500);\r\n        $('#tag-filter-input').val('').effect(\"highlight\", {color: 'green'}, 500);\r\n        $('#type-filter-input').val('').effect(\"highlight\", {color: 'green'}, 500);\r\n        $('#search_bar').val('').effect(\"highlight\", {color: 'green'}, 500);\r\n        update_filter();\r\n        update_search();\r\n        requirements_table.draw();\r\n    });\r\n\r\n    // Listen for tool section triggers.\r\n    $('#gen-req-from-selection').click(function () {\r\n        let req_ids = [];\r\n        requirements_table.rows( {search:'applied'} ).every( function () {\r\n            let d = this.data();\r\n            req_ids.push(d['id']);\r\n         } );\r\n        $('#selected_requirement_ids').val(JSON.stringify(req_ids));\r\n        $('#generate_req_form').submit();\r\n    });\r\n\r\n    $('#gen-csv-from-selection').click(function () {\r\n        let req_ids = [];\r\n        requirements_table.rows( {search:'applied'} ).every( function () {\r\n            let d = this.data();\r\n            req_ids.push(d['id']);\r\n         } );\r\n        $('#selected_csv_requirement_ids').val(JSON.stringify(req_ids));\r\n        $('#generate_csv_form').submit();\r\n    });\r\n\r\n    // Column toggling\r\n    $('.colum-toggle-button').on( 'click', function (e) {\r\n        e.preventDefault();\r\n\r\n        // Get the column API object\r\n        let column = requirements_table.column($(this).attr('data-column'));\r\n\r\n        // Toggle the visibility\r\n        column.visible( ! column.visible() );\r\n        update_visible_columns_information();\r\n    } );\r\n\r\n    $('.reset-colum-toggle').on('click', function (e) {\r\n        e.preventDefault();\r\n        requirements_table.columns( '.default-col' ).visible( true );\r\n        requirements_table.columns( '.extra-col' ).visible( false );\r\n        update_visible_columns_information();\r\n    });\r\n    update_visible_columns_information();\r\n\r\n    // Select rows\r\n    $('.select-all-button').on('click', function (e) {\r\n        // Toggle selection on\r\n        if ($( this ).hasClass('btn-secondary')) {\r\n            requirements_table.rows( {page:'current'} ).select();\r\n        }\r\n        else { // Toggle selection off\r\n            requirements_table.rows( {page:'current'} ).deselect();\r\n        }\r\n        // Toggle button state.\r\n        $('.select-all-button').toggleClass('btn-secondary btn-primary');\r\n    });\r\n\r\n    // Toggle \"Select all rows to `off` on user specific selection.\"\r\n    requirements_table.on( 'user-select', function ( ) {\r\n        let select_buttons = $('.select-all-button');\r\n        select_buttons.removeClass('btn-primary');\r\n        select_buttons.addClass('btn-secondary ');\r\n    });\r\n\r\n    // Bind autocomplete for \"edit-selected\" inputs\r\n    $('#multi-add-tag-input, #multi-remove-tag-input').autocomplete({\r\n        minLength: 0,\r\n        source: available_tags,\r\n        delay: 100\r\n    }).on('focus', function() { $(this).keydown(); }).val('');\r\n\r\n    $('#multi-set-status-input').autocomplete({\r\n        minLength: 0,\r\n        source: available_status,\r\n        delay: 100\r\n    }).on('focus', function() { $(this).keydown(); }).val('');\r\n\r\n    $('.apply-multi-edit').click(function () {\r\n        apply_multi_edit(requirements_table);\r\n    });\r\n\r\n    $('.add_top_guess_button').confirmation({\r\n      rootSelector: '.add_top_guess_button'\r\n    }).click(function () {\r\n        add_top_guess_to_selected_requirements(requirements_table);\r\n    });\r\n}\r\n\r\n/**\r\n * Fetch requirements from hanfor api and build the requirements table.\r\n * Apply search queries to table\r\n * Bind button/links to events.\r\n * @param columnDefs predefined columDefs (https://datatables.net/reference/option/columnDefs)\r\n */\r\nfunction init_datatable(columnDefs) {\r\n    let requirements_table = $('#requirements_table').DataTable({\r\n        \"language\": {\r\n          \"emptyTable\": \"Loading data.\"\r\n        },\r\n        \"paging\": true,\r\n        \"stateSave\": true,\r\n        \"select\": {\r\n            style:    'os',\r\n            selector: 'td:first-child'\r\n        },\r\n        \"pageLength\": 50,\r\n        \"lengthMenu\": [[10, 50, 100, 500, -1], [10, 50, 100, 500, \"All\"]],\r\n        \"dom\": 'rt<\"container\"<\"row\"<\"col-md-6\"li><\"col-md-6\"p>>>',\r\n        \"ajax\": \"api/req/gets\",\r\n        \"deferRender\": true,\r\n        \"columnDefs\": columnDefs,\r\n        \"createdRow\": function( row, data, dataIndex ) {\r\n            if (data['type'] === 'Heading') {\r\n                $(row).addClass( 'bg-primary' );\r\n            }\r\n            if (data['type'] === 'Information') {\r\n                $(row).addClass( 'table-info' );\r\n            }\r\n            if (data['type'] === 'Requirement') {\r\n                $(row).addClass( 'table-warning' );\r\n            }\r\n            if (data['type'] === 'not set') {\r\n                $(row).addClass( 'table-light');\r\n            }\r\n        },\r\n        \"infoCallback\": function( settings, start, end, max, total, pre ) {\r\n            var api = this.api();\r\n            var pageInfo = api.page.info();\r\n\r\n            $('#clear-all-filters-text').html(\"Showing \" + total +\"/\"+ pageInfo.recordsTotal + \". Clear all.\");\r\n\r\n            let result = \"Showing \" + start + \" to \" + end + \" of \" + total + \" entries\";\r\n            result += \" (filtered from \" + pageInfo.recordsTotal + \" total entries).\";\r\n\r\n            return result;\r\n        },\r\n        \"initComplete\" : function() {\r\n            $('#search_bar').val(req_search_string);\r\n            $('#type-filter-input').val(filter_type_string);\r\n            $('#tag-filter-input').val(filter_tag_string);\r\n            $('#status-filter-input').val(filter_status_string);\r\n\r\n            bind_requirement_id_to_modals(requirements_table);\r\n            init_datatable_manipulators(requirements_table);\r\n\r\n            process_url_query(get_query);\r\n            update_search();\r\n            update_filter();\r\n\r\n            // Enable Hanfor specific requirements table filtering.\r\n            $.fn.dataTable.ext.search.push(\r\n                function( settings, data, dataIndex ) {\r\n                    // data contains the row. data[0] is the content of the first column in the actual row.\r\n                    // Return true to include the row into the data. false to exclude.\r\n                    return evaluate_search(data);\r\n                }\r\n            );\r\n\r\n            this.api().draw();\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Get the color for a tag\r\n */\r\nfunction get_tag_color(tag_name){\r\n    return tag_colors.hasOwnProperty(tag_name) ? tag_colors[tag_name] : '#5bc0de';\r\n}\r\n\r\n\r\n/**\r\n * Load available guesses into the modal.\r\n */\r\nfunction fetch_available_guesses() {\r\n    let modal = $('#requirement_guess_modal');\r\n    let available_guesses_cards = $('#available_guesses_cards');\r\n    let modal_content = $('.modal-content');\r\n    let requirement_id = $('#requirement_id').val();\r\n\r\n    modal.modal({\r\n        keyboard: false\r\n    });\r\n    modal.modal('show');\r\n    modal_content.LoadingOverlay('show');\r\n    available_guesses_cards.html('');\r\n\r\n    function add_available_guess(guess) {\r\n        let template = '<div id=\"available_guesses_cards\" >' +\r\n            '                <div class=\"card\">' +\r\n            '                    <div class=\"pl-1 pr-1\">' +\r\n            '                        <p>'+\r\n            guess['string'] +\r\n            '                        </p>' +\r\n            '                    </div>' +\r\n            '                    <button type=\"button\" class=\"btn btn-success btn-sm add_guess\"' +\r\n            '                            title=\"Add formalization\"' +\r\n            '                            data-scope=\"' + guess['scope'] + '\"' +\r\n            '                            data-pattern=\"' + guess['pattern'] + '\"' +\r\n            '                            data-mapping=\\'' + JSON.stringify(guess['mapping']) + '\\'>' +\r\n            '                        <strong>+ Add this formalization +</strong>' +\r\n            '                    </button>' +\r\n            '                </div>' +\r\n            '            </div>';\r\n        available_guesses_cards.append(template);\r\n    }\r\n\r\n    $.post( \"api/req/get_available_guesses\",\r\n        {\r\n            requirement_id: requirement_id\r\n        },\r\n        function (data) {\r\n            if (data['success'] === false) {\r\n                alert(data['errormsg'])\r\n            } else {\r\n                for (let i = 0; i < data['available_guesses'].length; i++) {\r\n                    add_available_guess(data['available_guesses'][i]);\r\n                }\r\n            }\r\n    }).done(function () {\r\n        $('.add_guess').click(function () {\r\n            add_formalization_from_guess($(this).data('scope'), $(this).data('pattern'), $(this).data('mapping'));\r\n        });\r\n        modal_content.LoadingOverlay('hide', true);\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Load requirements datatable definitions. Trigger build of a fresh requirement datatable.\r\n */\r\nfunction load_datatable(){\r\n    // Initialize the Column defs.\r\n    // First set the static colum definitions.\r\n    let columnDefs = [\r\n        {\r\n            \"orderable\": false,\r\n            \"className\": 'select-checkbox',\r\n            \"targets\": [0],\r\n            \"data\": null,\r\n            \"defaultContent\": \"\"\r\n        },\r\n        {\r\n            \"targets\": [1],\r\n            \"data\": \"pos\"\r\n        },\r\n        {\r\n            \"targets\": [2],\r\n            \"data\": \"id\",\r\n            \"render\": function (data, type, row, meta) {\r\n                result = '<a href=\"#\">' + data + '</a>';\r\n                return result;\r\n            }\r\n        },\r\n        {\r\n            \"targets\": [3],\r\n            \"data\": \"desc\"\r\n        },\r\n        {\r\n            \"targets\": [4],\r\n            \"data\": \"type\",\r\n            \"render\": function (data, type, row, meta) {\r\n                if (available_types.indexOf(data) <= -1) {\r\n                    available_types.push(data);\r\n                }\r\n                return data;\r\n            }\r\n        },\r\n        {\r\n            \"targets\": [5],\r\n            \"data\": \"tags\",\r\n            \"render\": function (data, type, row, meta) {\r\n                result = '';\r\n                $(data).each(function (id, tag) {\r\n                    if (tag.length > 0) {\r\n                        result += '<span class=\"badge\" style=\"background-color: ' + get_tag_color(tag) + '\">' +\r\n                            tag + '</span></br>';\r\n                        // Add tag to available tags\r\n                        if (available_tags.indexOf(tag) <= -1) {\r\n                            available_tags.push(tag);\r\n                        }\r\n                    }\r\n                });\r\n                if (row.formal.length > 0) {\r\n                    result += '<span class=\"badge badge-success\">has_formalization</span></br>';\r\n                }\r\n                return result;\r\n            }\r\n\r\n        },\r\n        {\r\n            \"targets\": [6],\r\n            \"data\": \"status\",\r\n            \"render\": function (data, type, row, meta) {\r\n                result = '<span class=\"badge badge-info\">' + data + '</span></br>';\r\n                return result;\r\n            }\r\n        },\r\n        {\r\n            \"targets\": [7],\r\n            \"data\": \"formal\",\r\n            \"render\": function (data, type, row, meta) {\r\n                result = '';\r\n                if (row.formal.length > 0) {\r\n                    $(data).each(function (id, formalization) {\r\n                        if (formalization.length > 0) {\r\n                            result += '<p>' + formalization + '</p>';\r\n                        }\r\n                    });\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n    ];\r\n    // Load generic colums.\r\n    $.get( \"api/table/colum_defs\", '', function (data) {\r\n        const dataLength = data['col_defs'].length;\r\n        for (let i = 0; i < dataLength; i++) {\r\n            columnDefs.push(\r\n            {\r\n                \"targets\": [parseInt(data['col_defs'][i]['target'])],\r\n                \"data\": data['col_defs'][i]['csv_name'],\r\n                \"visible\": false,\r\n                \"searchable\": true\r\n            });\r\n        }\r\n    }).done(function () {\r\n            init_datatable(columnDefs);\r\n    });\r\n}\r\n\r\n/**\r\n * Handle requirement modal hiding event.\r\n * Prevent hiding on unsaved changes by asking user feedback (discard, save, back to edit).\r\n * @param event | the modal hiding event.\r\n */\r\nfunction modal_closing_routine(event) {\r\n    const unsaved_changes = $('#requirement_modal').data('unsaved_changes');\r\n    if (unsaved_changes === true) {\r\n        const force_close = confirm(\"You have unsaved changes, do you really want to close?\");\r\n        if (force_close !== true) {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize the requirement modal behaviour.\r\n */\r\nfunction init_modal() {\r\n    let requirement_modal = $('#requirement_modal');\r\n    // Initialize tag autocomplete filed in the requirements modal.\r\n    $('#requirement_tag_field')\r\n        .tokenfield({\r\n            autocomplete: {\r\n                source: available_tags,\r\n                delay: 100\r\n            },\r\n            showAutocompleteOnFocus: true\r\n        })\r\n        .change(function (e) {\r\n            requirement_modal.data('unsaved_changes', true);\r\n        });\r\n\r\n    $('#requirement_status').change(function() {\r\n        $('#requirement_modal').data('unsaved_changes', true);\r\n    });\r\n\r\n    requirement_modal.on('hide.bs.modal', function (event) {\r\n        modal_closing_routine(event);\r\n    });\r\n\r\n    // Handle ESC key\r\n    $(document).keyup(function(e) {\r\n        // If modal is open and ESC pressed (ESC maps to keyCode \"27\")\r\n        if ($('.modal:visible').length && e.keyCode === 27){\r\n            let focused_input = $('input[type=text], textarea, select').filter(\":focus\");\r\n            // If no input elements in focus => Close modal.\r\n            if (focused_input.length === 0) {\r\n                // First hide the autoguess modal\r\n                if($('#requirement_guess_modal:visible').length){\r\n                    $('#requirement_guess_modal').modal('hide');\r\n                } else {\r\n                    $('#requirement_modal').modal('hide');\r\n                }\r\n            } else {\r\n                // Defocus input elements.\r\n                focused_input.each(function( index ) {\r\n                    $( this ).blur();\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    // Clear the Modal after closing modal.\r\n    // In case of stacked modals and on modal closing:\r\n    // Prevent removal of modal-open class from body if a modal remains. This will keep the scrollbar intact.\r\n    requirement_modal.on('hidden.bs.modal', function (e) {\r\n        $('#requirement_tag_field').val('');\r\n        $('#requirement_tag_field-tokenfield').val('');\r\n    });\r\n\r\n    // Listener for adding new formalizations.\r\n    $('#add_formalization').click(function () {\r\n        add_formalization();\r\n    });\r\n\r\n    // Listener for adding new geussed formalizations.\r\n    $('#add_gussed_formalization').click(function () {\r\n        fetch_available_guesses();\r\n    });\r\n\r\n    $(\".modal\").on('hidden.bs.modal', function (event) {\r\n        if ($('.modal:visible').length) {\r\n            $('body').addClass('modal-open');\r\n        }\r\n    });\r\n\r\n    // Initialize variables.\r\n    update_vars();\r\n}\r\n\r\n\r\n/**\r\n * Load the hanfor frontend meta settings.\r\n */\r\nfunction load_meta_settings() {\r\n    $.get( \"api/meta/get\", '', function (data) {\r\n        tag_colors = data['tag_colors'];\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Find the datatable row index for a requirement by its requirement id.\r\n * @param {number} rid the requirement id.\r\n * @returns {number} row_index the datatables row index.\r\n */\r\nfunction get_rowidx_by_reqid(rid) {\r\n    let requirement_table = $('#requirements_table').DataTable();\r\n    let result = -1;\r\n    let filteredData = requirement_table\r\n        .column( 2 )\r\n        .data()\r\n        .filter( function ( value, index ) {\r\n            if (value === rid) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        } );\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n * Refresh the hanfor frontend logs.\r\n */\r\nfunction update_logs() {\r\n    $.get( \"api/logs/get\", '', function (data) {\r\n        $('#log_textarea').html(data);\r\n    }).done(function () {\r\n        // Bind direct requirement links to load the modal.\r\n        $('.req_direct_link').click( function () {\r\n            load_requirement(get_rowidx_by_reqid($(this).data(\"rid\")));\r\n        });\r\n        $('#log_textarea').scrollTop( 100000 );\r\n    });\r\n}\r\n\r\n/**\r\n * Start the app.\r\n */\r\n$(document).ready(function() {\r\n    load_meta_settings();\r\n    load_datatable();\r\n    init_modal();\r\n    update_logs();\r\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9yZXF1aXJlbWVudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9yZXF1aXJlbWVudHMuanM/NzI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdnYXNwYXJlc2dhbmdhLWpxdWVyeS1sb2FkaW5nLW92ZXJsYXknKTtcclxucmVxdWlyZSgnYm9vdHN0cmFwJyk7XHJcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1jb25maXJtYXRpb24yJyk7XHJcbnJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJzNCcpO1xyXG5yZXF1aXJlKCdkYXRhdGFibGVzLm5ldC1zZWxlY3QnKTtcclxucmVxdWlyZSgnanF1ZXJ5LXVpL3VpL3dpZGdldHMvYXV0b2NvbXBsZXRlJyk7XHJcbnJlcXVpcmUoJ2pxdWVyeS11aS91aS9lZmZlY3RzL2VmZmVjdC1oaWdobGlnaHQnKTtcclxucmVxdWlyZSgnLi9ib290c3RyYXAtdG9rZW5maWVsZC5qcycpO1xyXG5cclxuLy8gR2xvYmFsc1xyXG5jb25zdCB7IFNlYXJjaE5vZGUgfSA9IHJlcXVpcmUoJy4vZGF0YXRhYmxlcy1hZHZhbmNlZC1zZWFyY2guanMnKTtcclxubGV0IEZ1c2UgPSByZXF1aXJlKCdmdXNlLmpzJyk7XHJcbmxldCB7IFRleHRjb21wbGV0ZSwgVGV4dGFyZWEgfSA9IHJlcXVpcmUoJ3RleHRjb21wbGV0ZScpO1xyXG5sZXQgZnVzZSA9IG5ldyBGdXNlKFtdLCB7fSk7XHJcblxyXG5sZXQgYXZhaWxhYmxlX3RhZ3MgPSBbJycsICdoYXNfZm9ybWFsaXphdGlvbiddO1xyXG5sZXQgYXZhaWxhYmxlX3N0YXR1cyA9IFsnJywgJ1RvZG8nLCAnUmV2aWV3JywgJ0RvbmUnXTtcclxubGV0IGF2YWlsYWJsZV90eXBlcyA9IFsnJ107XHJcbmxldCBhdmFpbGFibGVfdmFycyA9IFsnJ107XHJcbmxldCB2aXNpYmxlX2NvbHVtbnMgPSBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV07XHJcbmxldCBmaWx0ZXJfc2VhcmNoX2FycmF5ID0gW107XHJcbmxldCBnZXRfcXVlcnkgPSBKU09OLnBhcnNlKHNlYXJjaF9xdWVyeSk7IC8vIHNlYXJjaF9xdWVyeSBpcyBzZXQgaW4gaW5kZXguaHRtbFxyXG5sZXQgdGFnX2NvbG9ycyA9IHt9O1xyXG5sZXQgdHlwZV9pbmZlcmVuY2VfZXJyb3JzID0gW107XHJcbmxldCByZXFfc2VhcmNoX3N0cmluZyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3JlcV9zZWFyY2hfc3RyaW5nJyk7XHJcbmxldCBmaWx0ZXJfc3RhdHVzX3N0cmluZyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2ZpbHRlcl9zdGF0dXNfc3RyaW5nJyk7XHJcbmxldCBmaWx0ZXJfdGFnX3N0cmluZyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2ZpbHRlcl90YWdfc3RyaW5nJyk7XHJcbmxldCBmaWx0ZXJfdHlwZV9zdHJpbmcgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdmaWx0ZXJfdHlwZV9zdHJpbmcnKTtcclxubGV0IHNlYXJjaF90cmVlID0gdW5kZWZpbmVkO1xyXG5sZXQgZmlsdGVyX3RyZWUgPSB1bmRlZmluZWQ7XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgc2VhcmNoIGV4cHJlc3Npb24gdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZV9zZWFyY2goKSB7XHJcbiAgICByZXFfc2VhcmNoX3N0cmluZyA9ICQoJyNzZWFyY2hfYmFyJykudmFsKCkudHJpbSgpO1xyXG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgncmVxX3NlYXJjaF9zdHJpbmcnLCByZXFfc2VhcmNoX3N0cmluZyk7XHJcbiAgICBzZWFyY2hfdHJlZSA9IFNlYXJjaE5vZGUuZnJvbVF1ZXJ5KHJlcV9zZWFyY2hfc3RyaW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgZmlsdGVyIHNlYXJjaCB0cmVlIHVzZWQgdG8gZmlsdGVyIHRoZSB0YWJsZSBieSB0aGUgdmFsdWVzIGZyb20gdGhlIEZpbHRlciB0YWIuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVfZmlsdGVyKCkge1xyXG4gICAgZmlsdGVyX3NlYXJjaF9hcnJheSA9IFtdO1xyXG4gICAgZnVuY3Rpb24gcGFkX3dpdGhfcGFyYW50aGVzZXMoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gW1wiKFwiXS5jb25jYXQoYXJyYXksIFtcIilcIl0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkX3F1ZXJ5KGFycmF5LCBxdWVyeSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KFtcIjpBTkQ6XCJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChwYWRfd2l0aF9wYXJhbnRoZXNlcyhTZWFyY2hOb2RlLmF3ZXNvbWVRdWVyeVNwbGl0dDByKHF1ZXJ5LCB0YXJnZXQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheVxyXG4gICAgfVxyXG4gICAgZmlsdGVyX3N0YXR1c19zdHJpbmcgPSAkKCcjc3RhdHVzLWZpbHRlci1pbnB1dCcpLnZhbCgpO1xyXG4gICAgZmlsdGVyX3RhZ19zdHJpbmcgPSAkKCcjdGFnLWZpbHRlci1pbnB1dCcpLnZhbCgpO1xyXG4gICAgZmlsdGVyX3R5cGVfc3RyaW5nID0gJCgnI3R5cGUtZmlsdGVyLWlucHV0JykudmFsKCk7XHJcblxyXG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnZmlsdGVyX3N0YXR1c19zdHJpbmcnLCBmaWx0ZXJfc3RhdHVzX3N0cmluZyk7XHJcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdmaWx0ZXJfdGFnX3N0cmluZycsIGZpbHRlcl90YWdfc3RyaW5nKTtcclxuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2ZpbHRlcl90eXBlX3N0cmluZycsIGZpbHRlcl90eXBlX3N0cmluZyk7XHJcblxyXG4gICAgZmlsdGVyX3NlYXJjaF9hcnJheSA9IGFkZF9xdWVyeShmaWx0ZXJfc2VhcmNoX2FycmF5LCBmaWx0ZXJfdHlwZV9zdHJpbmcsIDQpO1xyXG4gICAgZmlsdGVyX3NlYXJjaF9hcnJheSA9IGFkZF9xdWVyeShmaWx0ZXJfc2VhcmNoX2FycmF5LCBmaWx0ZXJfdGFnX3N0cmluZywgNSk7XHJcbiAgICBmaWx0ZXJfc2VhcmNoX2FycmF5ID0gYWRkX3F1ZXJ5KGZpbHRlcl9zZWFyY2hfYXJyYXksIGZpbHRlcl9zdGF0dXNfc3RyaW5nLCA2KTtcclxuXHJcbiAgICBmaWx0ZXJfdHJlZSA9IFNlYXJjaE5vZGUuc2VhcmNoQXJyYXlUb1RyZWUoZmlsdGVyX3NlYXJjaF9hcnJheSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBldmFsdWF0ZV9zZWFyY2goZGF0YSl7XHJcbiAgICByZXR1cm4gc2VhcmNoX3RyZWUuZXZhbHVhdGUoZGF0YSwgdmlzaWJsZV9jb2x1bW5zKSAmJiBmaWx0ZXJfdHJlZS5ldmFsdWF0ZShkYXRhLCB2aXNpYmxlX2NvbHVtbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHkgYSBVUkwgc2VhcmNoIHF1ZXJ5IHRvIHRoZSByZXF1aXJlbWVudHMgdGFibGUuXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudHNfdGFibGVcclxuICogQHBhcmFtIGdldF9xdWVyeVxyXG4gKi9cclxuZnVuY3Rpb24gcHJvY2Vzc191cmxfcXVlcnkoZ2V0X3F1ZXJ5KSB7XHJcbiAgICAvLyBBcHBseSBzZWFyY2ggaWYgd2UgaGF2ZSBvbmUuXHJcbiAgICBpZiAoZ2V0X3F1ZXJ5LnEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHBhZChudW0pIHtcclxuICAgICAgICAgICAgbGV0IHMgPSBcIjAwXCIgKyBudW07XHJcbiAgICAgICAgICAgIHJldHVybiBzLnN1YnN0cihzLmxlbmd0aC0yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgZmlsdGVycy5cclxuICAgICAgICAkKCcjc3RhdHVzLWZpbHRlci1pbnB1dCcpLnZhbCgnJyk7XHJcbiAgICAgICAgJCgnI3RhZy1maWx0ZXItaW5wdXQnKS52YWwoJycpO1xyXG4gICAgICAgICQoJyN0eXBlLWZpbHRlci1pbnB1dCcpLnZhbCgnJyk7XHJcblxyXG4gICAgICAgIC8vIFNldCBzZWFyY2ggZm9yIHJlcXVpcmVtZW50IElEXHJcbiAgICAgICAgY29uc3QgcyA9ICc6Q09MX0lOREVYXycgKyBwYWQoZ2V0X3F1ZXJ5LmNvbCkudG9TdHJpbmcoKSArICc6JyArIGdldF9xdWVyeS5xO1xyXG4gICAgICAgICQoJyNzZWFyY2hfYmFyJykudmFsKHMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RvcmVzIHRoZSBhY3RpdmUgKGluIG1vZGFsKSByZXF1aXJlbWVudCBhbmQgdXBkYXRlcyB0aGUgcm93IGluIHRoZSByZXF1aXJlbWVudHMgdGFibGUuXHJcbiAqIEBwYXJhbSB7RGF0YVRhYmxlfSByZXF1aXJlbWVudHNfdGFibGVcclxuICovXHJcbmZ1bmN0aW9uIHN0b3JlX3JlcXVpcmVtZW50KHJlcXVpcmVtZW50c190YWJsZSkge1xyXG4gICAgbGV0IHJlcXVpcmVtZW50X21vZGFsX2NvbnRlbnQgPSAkKCcubW9kYWwtY29udGVudCcpO1xyXG4gICAgcmVxdWlyZW1lbnRfbW9kYWxfY29udGVudC5Mb2FkaW5nT3ZlcmxheSgnc2hvdycpO1xyXG5cclxuICAgIGNvbnN0IHJlcV9pZCA9ICQoJyNyZXF1aXJlbWVudF9pZCcpLnZhbCgpO1xyXG4gICAgY29uc3QgcmVxX3RhZ3MgPSAkKCcjcmVxdWlyZW1lbnRfdGFnX2ZpZWxkJykudmFsKCk7XHJcbiAgICBjb25zdCByZXFfc3RhdHVzID0gJCgnI3JlcXVpcmVtZW50X3N0YXR1cycpLnZhbCgpO1xyXG4gICAgY29uc3QgdXBkYXRlZF9mb3JtYWxpemF0aW9uID0gJCgnI3JlcXVpcmVtZW50X21vZGFsJykuZGF0YSgndXBkYXRlZF9mb3JtYWxpemF0aW9uJyk7XHJcbiAgICBjb25zdCBhc3NvY2lhdGVkX3Jvd19pZCA9IHBhcnNlSW50KCQoJyNtb2RhbF9hc3NvY2lhdGVkX3Jvd19pbmRleCcpLnZhbCgpKTtcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgZm9ybWFsaXphdGlvbnNcclxuICAgIGxldCBmb3JtYWxpemF0aW9ucyA9IHt9O1xyXG4gICAgJCgnLmZvcm1hbGl6YXRpb25fY2FyZCcpLmVhY2goZnVuY3Rpb24gKCBpbmRleCApIHtcclxuICAgICAgICAvLyBTY29wZSBhbmQgUGF0dGVyblxyXG4gICAgICAgIGxldCBmb3JtYWxpemF0aW9uID0ge307XHJcbiAgICAgICAgZm9ybWFsaXphdGlvblsnaWQnXSA9ICQodGhpcykuYXR0cigndGl0bGUnKTtcclxuICAgICAgICAkKCB0aGlzICkuZmluZCggJ3NlbGVjdCcpLmVhY2goIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCQoIHRoaXMgKS5oYXNDbGFzcygnc2NvcGVfc2VsZWN0b3InKSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWFsaXphdGlvblsnc2NvcGUnXSA9ICQoIHRoaXMgKS52YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJCggdGhpcyApLmhhc0NsYXNzKCdwYXR0ZXJuX3NlbGVjdG9yJykpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hbGl6YXRpb25bJ3BhdHRlcm4nXSA9ICQoIHRoaXMgKS52YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBFeHByZXNzaW9uc1xyXG4gICAgICAgIGZvcm1hbGl6YXRpb25bJ2V4cHJlc3Npb25fbWFwcGluZyddID0ge307XHJcbiAgICAgICAgJCggdGhpcyApLmZpbmQoIFwidGV4dGFyZWEucmVxaXJlbWVudC12YXJpYWJsZVwiICkuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmF0dHIoJ3RpdGxlJykgIT09ICcnKVxyXG4gICAgICAgICAgICBmb3JtYWxpemF0aW9uWydleHByZXNzaW9uX21hcHBpbmcnXVskKHRoaXMpLmF0dHIoJ3RpdGxlJyldID0gJCh0aGlzKS52YWwoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9ybWFsaXphdGlvbnNbZm9ybWFsaXphdGlvblsnaWQnXV0gPSBmb3JtYWxpemF0aW9uO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIHJlcXVpcmVtZW50LlxyXG4gICAgJC5wb3N0KCBcImFwaS9yZXEvdXBkYXRlXCIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogcmVxX2lkLFxyXG4gICAgICAgICAgICByb3dfaWR4OiBhc3NvY2lhdGVkX3Jvd19pZCxcclxuICAgICAgICAgICAgdXBkYXRlX2Zvcm1hbGl6YXRpb246IHVwZGF0ZWRfZm9ybWFsaXphdGlvbixcclxuICAgICAgICAgICAgdGFnczogcmVxX3RhZ3MsXHJcbiAgICAgICAgICAgIHN0YXR1czogcmVxX3N0YXR1cyxcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbnM6IEpTT04uc3RyaW5naWZ5KGZvcm1hbGl6YXRpb25zKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVXBkYXRlIHJlcXVpcmVtZW50cyB0YWJsZSBvbiBzdWNjZXNzIG9yIHNob3cgYW4gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgcmVxdWlyZW1lbnRfbW9kYWxfY29udGVudC5Mb2FkaW5nT3ZlcmxheSgnaGlkZScsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVsnc3VjY2VzcyddID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZGF0YVsnZXJyb3Jtc2cnXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1aXJlbWVudHNfdGFibGUucm93KGFzc29jaWF0ZWRfcm93X2lkKS5kYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgJCgnI3JlcXVpcmVtZW50X21vZGFsJykuZGF0YSgndW5zYXZlZF9jaGFuZ2VzJywgZmFsc2UpLm1vZGFsKCdoaWRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVwZGF0ZV9sb2dzKCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKipcclxuICpcclxuICogQHBhcmFtIHJlcXVpcmVtZW50c190YWJsZVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFVzZXIgc2VsZWN0ZWQgcmVxdWlyZW1lbnQgaWRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0X3NlbGVjdGVkX3JlcXVpcmVtZW50X2lkcyhyZXF1aXJlbWVudHNfdGFibGUpIHtcclxuICAgIGxldCBzZWxlY3RlZF9pZHMgPSBbXTtcclxuICAgIHJlcXVpcmVtZW50c190YWJsZS5yb3dzKCB7c2VsZWN0ZWQ6dHJ1ZX0gKS5ldmVyeSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5kYXRhKCk7XHJcbiAgICAgICAgc2VsZWN0ZWRfaWRzLnB1c2goZFsnaWQnXSk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgcmV0dXJuIHNlbGVjdGVkX2lkc1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gYXBwbHlfbXVsdGlfZWRpdChyZXF1aXJlbWVudHNfdGFibGUpIHtcclxuICAgIGxldCBwYWdlID0gJCgnYm9keScpO1xyXG4gICAgcGFnZS5Mb2FkaW5nT3ZlcmxheSgnc2hvdycpO1xyXG4gICAgbGV0IGFkZF90YWcgPSAkKCcjbXVsdGktYWRkLXRhZy1pbnB1dCcpLnZhbCgpLnRyaW0oKTtcclxuICAgIGxldCByZW1vdmVfdGFnID0gJCgnI211bHRpLXJlbW92ZS10YWctaW5wdXQnKS52YWwoKS50cmltKCk7XHJcbiAgICBsZXQgc2V0X3N0YXR1cyA9ICQoJyNtdWx0aS1zZXQtc3RhdHVzLWlucHV0JykudmFsKCkudHJpbSgpO1xyXG4gICAgbGV0IHNlbGVjdGVkX2lkcyA9IGdldF9zZWxlY3RlZF9yZXF1aXJlbWVudF9pZHMocmVxdWlyZW1lbnRzX3RhYmxlKTtcclxuXHJcbiAgICAkLnBvc3QoIFwiYXBpL3JlcS9tdWx0aV91cGRhdGVcIixcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFkZF90YWc6IGFkZF90YWcsXHJcbiAgICAgICAgICAgIHJlbW92ZV90YWc6IHJlbW92ZV90YWcsXHJcbiAgICAgICAgICAgIHNldF9zdGF0dXM6IHNldF9zdGF0dXMsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkX2lkczogSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWRfaWRzKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVXBkYXRlIHJlcXVpcmVtZW50cyB0YWJsZSBvbiBzdWNjZXNzIG9yIHNob3cgYW4gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgcGFnZS5Mb2FkaW5nT3ZlcmxheSgnaGlkZScsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVsnc3VjY2VzcyddID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZGF0YVsnZXJyb3Jtc2cnXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRfdG9wX2d1ZXNzX3RvX3NlbGVjdGVkX3JlcXVpcmVtZW50cyhyZXF1aXJlbWVudHNfdGFibGUpIHtcclxuICAgIGxldCBwYWdlID0gJCgnYm9keScpO1xyXG4gICAgcGFnZS5Mb2FkaW5nT3ZlcmxheSgnc2hvdycpO1xyXG4gICAgbGV0IHNlbGVjdGVkX2lkcyA9IGdldF9zZWxlY3RlZF9yZXF1aXJlbWVudF9pZHMocmVxdWlyZW1lbnRzX3RhYmxlKTtcclxuICAgIGxldCBpbnNlcnRfbW9kZSA9ICQoJyN0b3BfZ3Vlc3NfYXBwZW5kX21vZGUnKS52YWwoKTtcclxuXHJcbiAgICAkLnBvc3QoIFwiYXBpL3JlcS9tdWx0aV9hZGRfdG9wX2d1ZXNzXCIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZWxlY3RlZF9pZHM6IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkX2lkcyksXHJcbiAgICAgICAgICAgIGluc2VydF9tb2RlOiBpbnNlcnRfbW9kZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVXBkYXRlIHJlcXVpcmVtZW50cyB0YWJsZSBvbiBzdWNjZXNzIG9yIHNob3cgYW4gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgcGFnZS5Mb2FkaW5nT3ZlcmxheSgnaGlkZScsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVsnc3VjY2VzcyddID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZGF0YVsnZXJyb3Jtc2cnXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUvZGlzYWJsZSB0aGUgYWN0aXZlIHZhcmlhYmxlcyAoUCwgUSwgUiwgLi4uKSBpbiB0aGUgcmVxdWlyZW1lbnQgbW9kYWwgYmFzZWQgb24gc2NvcGUgYW5kIHBhdHRlcm4uXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVfdmFycygpIHtcclxuICAgICQoJy5yZXF1aXJlbWVudF92YXJfZ3JvdXAnKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKCB0aGlzICkuaGlkZSgpO1xyXG4gICAgICAgICQoIHRoaXMgKS5yZW1vdmVDbGFzcygndHlwZS1lcnJvcicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJCgnLmZvcm1hbGl6YXRpb25fY2FyZCcpLmVhY2goZnVuY3Rpb24gKCBpbmRleCApIHtcclxuICAgICAgICAvLyBGZXRjaCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgY29uc3QgZm9ybWFsaXphdGlvbl9pZCA9ICQodGhpcykuYXR0cigndGl0bGUnKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZF9zY29wZSA9ICQoJyNyZXF1aXJlbWVudF9zY29wZScgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZF9wYXR0ZXJuID0gJCgnI3JlcXVpcmVtZW50X3BhdHRlcm4nICsgZm9ybWFsaXphdGlvbl9pZCkudmFsKCk7XHJcbiAgICAgICAgbGV0IGhlYWRlciA9ICQoJyNmb3JtYWxpemF0aW9uX2hlYWRpbmcnICsgZm9ybWFsaXphdGlvbl9pZCk7XHJcbiAgICAgICAgbGV0IHZhcl9wID0gJCgnI3JlcXVpcmVtZW50X3Zhcl9ncm91cF9wJyArIGZvcm1hbGl6YXRpb25faWQpO1xyXG4gICAgICAgIGxldCB2YXJfcSA9ICQoJyNyZXF1aXJlbWVudF92YXJfZ3JvdXBfcScgKyBmb3JtYWxpemF0aW9uX2lkKTtcclxuICAgICAgICBsZXQgdmFyX3IgPSAkKCcjcmVxdWlyZW1lbnRfdmFyX2dyb3VwX3InICsgZm9ybWFsaXphdGlvbl9pZCk7XHJcbiAgICAgICAgbGV0IHZhcl9zID0gJCgnI3JlcXVpcmVtZW50X3Zhcl9ncm91cF9zJyArIGZvcm1hbGl6YXRpb25faWQpO1xyXG4gICAgICAgIGxldCB2YXJfdCA9ICQoJyNyZXF1aXJlbWVudF92YXJfZ3JvdXBfdCcgKyBmb3JtYWxpemF0aW9uX2lkKTtcclxuICAgICAgICBsZXQgdmFyX3UgPSAkKCcjcmVxdWlyZW1lbnRfdmFyX2dyb3VwX3UnICsgZm9ybWFsaXphdGlvbl9pZCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgcmVkIGJveGVzIGZvciB0eXBlIGluZmVyZW5jZSBmYWlsZWQgZXhwcmVzc2lvbnMuXHJcbiAgICAgICAgaWYgKGZvcm1hbGl6YXRpb25faWQgaW4gdHlwZV9pbmZlcmVuY2VfZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZV9pbmZlcmVuY2VfZXJyb3JzW2Zvcm1hbGl6YXRpb25faWRdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAkKCcjZm9ybWFsaXphdGlvbl92YXJfJyArIHR5cGVfaW5mZXJlbmNlX2Vycm9yc1tmb3JtYWxpemF0aW9uX2lkXVtpXSArIGZvcm1hbGl6YXRpb25faWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCd0eXBlLWVycm9yJyk7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXIuYWRkQ2xhc3MoJ3R5cGUtZXJyb3ItaGVhZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVhZGVyLnJlbW92ZUNsYXNzKCd0eXBlLWVycm9yLWhlYWQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN3aXRjaChzZWxlY3RlZF9zY29wZSkge1xyXG4gICAgICAgICAgICBjYXNlICdCRUZPUkUnOlxyXG4gICAgICAgICAgICBjYXNlICdBRlRFUic6XHJcbiAgICAgICAgICAgICAgICB2YXJfcC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnQkVUV0VFTic6XHJcbiAgICAgICAgICAgIGNhc2UgJ0FGVEVSX1VOVElMJzpcclxuICAgICAgICAgICAgICAgIHZhcl9wLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl9xLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2goc2VsZWN0ZWRfcGF0dGVybikge1xyXG4gICAgICAgICAgICBjYXNlICdBYnNlbmNlJzpcclxuICAgICAgICAgICAgY2FzZSAnVW5pdmVyc2FsaXR5JzpcclxuICAgICAgICAgICAgY2FzZSAnRXhpc3RlbmNlJzpcclxuICAgICAgICAgICAgY2FzZSAnQm91bmRlZEV4aXN0ZW5jZSc6XHJcbiAgICAgICAgICAgICAgICB2YXJfci5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnSW52YXJpYW50JzpcclxuICAgICAgICAgICAgY2FzZSAnUHJlY2VkZW5jZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1Jlc3BvbnNlJzpcclxuICAgICAgICAgICAgY2FzZSAnTWluRHVyYXRpb24nOlxyXG4gICAgICAgICAgICBjYXNlICdNYXhEdXJhdGlvbic6XHJcbiAgICAgICAgICAgIGNhc2UgJ0JvdW5kZWRSZWN1cnJlbmNlJzpcclxuICAgICAgICAgICAgICAgIHZhcl9yLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl9zLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdQcmVjZWRlbmNlQ2hhaW4xLTInOlxyXG4gICAgICAgICAgICBjYXNlICdQcmVjZWRlbmNlQ2hhaW4yLTEnOlxyXG4gICAgICAgICAgICBjYXNlICdSZXNwb25zZUNoYWluMS0yJzpcclxuICAgICAgICAgICAgY2FzZSAnUmVzcG9uc2VDaGFpbjItMSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0JvdW5kZWRSZXNwb25zZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0JvdW5kZWRJbnZhcmlhbmNlJzpcclxuICAgICAgICAgICAgY2FzZSAnVGltZUNvbnN0cmFpbmVkSW52YXJpYW50JzpcclxuICAgICAgICAgICAgICAgIHZhcl9yLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl9zLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl90LnNob3coKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdDb25zdHJhaW5lZENoYWluJzpcclxuICAgICAgICAgICAgY2FzZSAnVGltZUNvbnN0cmFpbmVkTWluRHVyYXRpb24nOlxyXG4gICAgICAgICAgICBjYXNlICdDb25zdHJhaW5lZFRpbWVkRXhpc3RlbmNlJzpcclxuICAgICAgICAgICAgICAgIHZhcl9yLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl9zLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl90LnNob3coKTtcclxuICAgICAgICAgICAgICAgIHZhcl91LnNob3coKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdOb3RGb3JtYWxpemFibGUnOlxyXG4gICAgICAgICAgICAgICAgdmFyX3AuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyX3EuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBmb3JtYWxpemF0aW9uIHRleHRhcmVhIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBzY29wZSBhbmQgZXhwcmVzc2lvbnMgaW4gUCwgUSwgUiwgUywgVC5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZV9mb3JtYWxpemF0aW9uKCkge1xyXG4gICAgJCgnLmZvcm1hbGl6YXRpb25fY2FyZCcpLmVhY2goZnVuY3Rpb24gKCBpbmRleCApIHtcclxuICAgICAgICAvLyBGZXRjaCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgY29uc3QgZm9ybWFsaXphdGlvbl9pZCA9ICQodGhpcykuYXR0cigndGl0bGUnKTtcclxuXHJcbiAgICAgICAgbGV0IGZvcm1hbGl6YXRpb24gPSAnJztcclxuICAgICAgICBjb25zdCBzZWxlY3RlZF9zY29wZSA9ICQoJyNyZXF1aXJlbWVudF9zY29wZScgKyBmb3JtYWxpemF0aW9uX2lkKS5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkX3BhdHRlcm4gPSAkKCcjcmVxdWlyZW1lbnRfcGF0dGVybicgKyBmb3JtYWxpemF0aW9uX2lkKS5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZWN0ZWRfc2NvcGUgIT09ICdOb25lJyAmJiBzZWxlY3RlZF9wYXR0ZXJuICE9PSAnTm9uZScpIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IHNlbGVjdGVkX3Njb3BlICsgJywgJyArIHNlbGVjdGVkX3BhdHRlcm4gKyAnLic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZm9ybWFsaXphdGlvbiB3aXRoIHZhcmlhYmxlcy5cclxuICAgICAgICBsZXQgdmFyX3AgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfcCcgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBsZXQgdmFyX3EgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfcScgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBsZXQgdmFyX3IgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfcicgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBsZXQgdmFyX3MgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfcycgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBsZXQgdmFyX3QgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfdCcgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuICAgICAgICBsZXQgdmFyX3UgPSAkKCcjZm9ybWFsaXphdGlvbl92YXJfdScgKyBmb3JtYWxpemF0aW9uX2lkKS52YWwoKTtcclxuXHJcbiAgICAgICAgaWYgKHZhcl9wLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1B9L2csIHZhcl9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcl9xLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1F9L2csIHZhcl9xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcl9yLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1J9L2csIHZhcl9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcl9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1N9L2csIHZhcl9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcl90Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1R9L2csIHZhcl90KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcl91Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9ybWFsaXphdGlvbiA9IGZvcm1hbGl6YXRpb24ucmVwbGFjZSgve1V9L2csIHZhcl91KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQoJyNjdXJyZW50X2Zvcm1hbGl6YXRpb25fdGV4dGFyZWEnICsgZm9ybWFsaXphdGlvbl9pZCkudmFsKGZvcm1hbGl6YXRpb24pO1xyXG4gICAgfSk7XHJcbiAgICAkKCcjcmVxdWlyZW1lbnRfbW9kYWwnKS5kYXRhKHtcclxuICAgICAgICAndW5zYXZlZF9jaGFuZ2VzJzogdHJ1ZSxcclxuICAgICAgICAndXBkYXRlZF9mb3JtYWxpemF0aW9uJzogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRfZm9ybWFsaXphdGlvbigpIHtcclxuICAgIC8vIFJlcXVlc3QgYSBuZXcgRm9ybWFsaXphdGlvbi4gQW5kIGFkZCBpdHMgZWRpdCBlbGVtZW50cyB0byB0aGUgbW9kYWwuXHJcbiAgICBsZXQgcmVxdWlyZW1lbnRfbW9kYWxfY29udGVudCA9ICQoJy5tb2RhbC1jb250ZW50Jyk7XHJcbiAgICByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdzaG93Jyk7XHJcblxyXG4gICAgY29uc3QgcmVxX2lkID0gJCgnI3JlcXVpcmVtZW50X2lkJykudmFsKCk7XHJcbiAgICAkLnBvc3QoIFwiYXBpL3JlcS9uZXdfZm9ybWFsaXphdGlvblwiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6IHJlcV9pZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVtZW50X21vZGFsX2NvbnRlbnQuTG9hZGluZ092ZXJsYXkoJ2hpZGUnLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGRhdGFbJ3N1Y2Nlc3MnXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KGRhdGFbJ2Vycm9ybXNnJ10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJCgnI2Zvcm1hbGl6YXRpb25fYWNjb3JkaW9uJykuYXBwZW5kKGRhdGFbJ2h0bWwnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVwZGF0ZV92YXJzKCk7XHJcbiAgICAgICAgdXBkYXRlX2Zvcm1hbGl6YXRpb24oKTtcclxuICAgICAgICBiaW5kX2V4cHJlc3Npb25fYnV0dG9ucygpO1xyXG4gICAgICAgIGJpbmRfdmFyX2F1dG9jb21wbGV0ZSgpO1xyXG4gICAgICAgIHVwZGF0ZV9sb2dzKCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFkZF9mb3JtYWxpemF0aW9uX2Zyb21fZ3Vlc3Moc2NvcGUsIHBhdHRlcm4sIG1hcHBpbmcpIHtcclxuICAgIC8vIFJlcXVlc3QgYSBuZXcgRm9ybWFsaXphdGlvbi4gQW5kIGFkZCBpdHMgZWRpdCBlbGVtZW50cyB0byB0aGUgbW9kYWwuXHJcbiAgICBsZXQgcmVxdWlyZW1lbnRfbW9kYWxfY29udGVudCA9ICQoJy5tb2RhbC1jb250ZW50Jyk7XHJcbiAgICByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdzaG93Jyk7XHJcblxyXG4gICAgbGV0IHJlcXVpcmVtZW50X2lkID0gJCgnI3JlcXVpcmVtZW50X2lkJykudmFsKCk7XHJcbiAgICAkLnBvc3QoIFwiYXBpL3JlcS9hZGRfZm9ybWFsaXphdGlvbl9mcm9tX2d1ZXNzXCIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXF1aXJlbWVudF9pZDogcmVxdWlyZW1lbnRfaWQsXHJcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcclxuICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcclxuICAgICAgICAgICAgbWFwcGluZzogSlNPTi5zdHJpbmdpZnkobWFwcGluZylcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdoaWRlJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhWydzdWNjZXNzJ10gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBhbGVydChkYXRhWydlcnJvcm1zZyddKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICQoJyNmb3JtYWxpemF0aW9uX2FjY29yZGlvbicpLmFwcGVuZChkYXRhWydodG1sJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVfdmFycygpO1xyXG4gICAgICAgIHVwZGF0ZV9mb3JtYWxpemF0aW9uKCk7XHJcbiAgICAgICAgYmluZF9leHByZXNzaW9uX2J1dHRvbnMoKTtcclxuICAgICAgICBiaW5kX3Zhcl9hdXRvY29tcGxldGUoKTtcclxuICAgICAgICB1cGRhdGVfbG9ncygpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkZWxldGVfZm9ybWFsaXphdGlvbihmb3JtYWxfaWQpIHtcclxuICAgIGxldCByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50ID0gJCgnLm1vZGFsLWNvbnRlbnQnKTtcclxuICAgIHJlcXVpcmVtZW50X21vZGFsX2NvbnRlbnQuTG9hZGluZ092ZXJsYXkoJ3Nob3cnKTtcclxuICAgIGNvbnN0IHJlcV9pZCA9ICQoJyNyZXF1aXJlbWVudF9pZCcpLnZhbCgpO1xyXG4gICAgJC5wb3N0KCBcImFwaS9yZXEvZGVsX2Zvcm1hbGl6YXRpb25cIixcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVtZW50X2lkOiByZXFfaWQsXHJcbiAgICAgICAgICAgIGZvcm1hbGl6YXRpb25faWQ6IGZvcm1hbF9pZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24oIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVtZW50X21vZGFsX2NvbnRlbnQuTG9hZGluZ092ZXJsYXkoJ2hpZGUnLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGRhdGFbJ3N1Y2Nlc3MnXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KGRhdGFbJ2Vycm9ybXNnJ10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJCgnI2Zvcm1hbGl6YXRpb25fYWNjb3JkaW9uJykuaHRtbChkYXRhWydodG1sJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVfdmFycygpO1xyXG4gICAgICAgIHVwZGF0ZV9mb3JtYWxpemF0aW9uKCk7XHJcbiAgICAgICAgYmluZF9leHByZXNzaW9uX2J1dHRvbnMoKTtcclxuICAgICAgICBiaW5kX3Zhcl9hdXRvY29tcGxldGUoKTtcclxuICAgICAgICB1cGRhdGVfbG9ncygpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBiaW5kX2V4cHJlc3Npb25fYnV0dG9ucygpIHtcclxuICAgICQoJy5mb3JtYWxpemF0aW9uX3NlbGVjdG9yJykuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVfdmFycygpO1xyXG4gICAgICAgIHVwZGF0ZV9mb3JtYWxpemF0aW9uKCk7XHJcbiAgICB9KTtcclxuICAgICQoJy5yZXFpcmVtZW50LXZhcmlhYmxlLCAucmVxX3Zhcl90eXBlJykuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVfZm9ybWFsaXphdGlvbigpO1xyXG4gICAgfSk7XHJcbiAgICAkKCcuZGVsZXRlX2Zvcm1hbGl6YXRpb24nKS5jb25maXJtYXRpb24oe1xyXG4gICAgICByb290U2VsZWN0b3I6ICcuZGVsZXRlX2Zvcm1hbGl6YXRpb24nXHJcbiAgICB9KS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZGVsZXRlX2Zvcm1hbGl6YXRpb24oICQodGhpcykuYXR0cignbmFtZScpICk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWxvYWQgZnVzZSB0aGUgZnV6enkgc2VhcmNoIHByb3ZpZGVyIHVzZWQgZm9yIGF1dG9jb21wbGV0ZS5cclxuICogZnVzZSB3aWxsIGJlIHJlbG9hZGVkIHdpdGggYXZhaWxhYmxlX3ZhcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVfZnVzZSgpIHtcclxuICAgIGxldCBvcHRpb25zID0ge1xyXG4gICAgICBzaG91bGRTb3J0OiB0cnVlLFxyXG4gICAgICB0aHJlc2hvbGQ6IDAuNixcclxuICAgICAgbG9jYXRpb246IDAsXHJcbiAgICAgIGRpc3RhbmNlOiAxMDAsXHJcbiAgICAgIG1heFBhdHRlcm5MZW5ndGg6IDEyLFxyXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGg6IDEsXHJcbiAgICAgIGtleXM6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICBmdXNlID0gbmV3IEZ1c2UoYXZhaWxhYmxlX3ZhcnMsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaCB0ZXJtIGluIHRoZSBmdXNlIGZ1enp5IHNlYXJjaCBwcm92aWRlci5cclxuICogRnVzZSBpcyBpbml0aWFsaXplZCB3aXRoIHRoZSBhdmFpbGFibGVfdmFycy5cclxuICogQHBhcmFtIHRlcm1cclxuICovXHJcbmZ1bmN0aW9uIGZ1enp5X3NlYXJjaCh0ZXJtKSB7XHJcbiAgICByZXR1cm4gZnVzZS5zZWFyY2godGVybSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQmluZCBhdXRvY29tcGxldGUgdHJpZ2dlciB0byBmb3JtYWxpemF0aW9uIGlucHV0IGZpZWxkcy5cclxuICogSW1wbGVtZW50IGF1dG9jb21wbGV0ZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGJpbmRfdmFyX2F1dG9jb21wbGV0ZSgpIHtcclxuICAgICQoIFwiLnJlcWlyZW1lbnQtdmFyaWFibGVcIiApLmVhY2goZnVuY3Rpb24gKCBpbmRleCApIHtcclxuICAgICAgICBsZXQgZWRpdG9yID0gbmV3IFRleHRhcmVhKHRoaXMpO1xyXG4gICAgICAgIGxldCB0ZXh0Y29tcGxldGUgPSBuZXcgVGV4dGNvbXBsZXRlKGVkaXRvciwge1xyXG4gICAgICAgICAgZHJvcGRvd246IHtcclxuICAgICAgICAgICAgICBtYXhDb3VudDogMTBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0ZXh0Y29tcGxldGUucmVnaXN0ZXIoW3tcclxuICAgICAgICAgIG1hdGNoOiAvKF58XFxzfFshPSZcXHw+XSspKFxcdyspJC8sXHJcbiAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh0ZXJtLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIGluY2x1ZGVfZWxlbXMgPSBmdXp6eV9zZWFyY2godGVybSk7XHJcblxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oMTAsIGluY2x1ZGVfZWxlbXMubGVuZ3RoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXZhaWxhYmxlX3ZhcnNbaW5jbHVkZV9lbGVtc1tpXV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyQxJyArIHZhbHVlICsgJyAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dKTtcclxuICAgICAgICAvLyBDbG9zZSBkcm9wZG93biBpZiB0ZXh0YXJlYSBpcyBubyBsb25nZXIgZm9jdXNlZC5cclxuICAgICAgICAkKHRoaXMpLm9uKCdibHVyIGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGV4dGNvbXBsZXRlLmRyb3Bkb3duLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcHJldmVudF9kb3VibGVfdG9rZW5faW5zZXJ0KCkge1xyXG4gICAgJCgnI3JlcXVpcmVtZW50X3RhZ19maWVsZCcpLm9uKCd0b2tlbmZpZWxkOmNyZWF0ZXRva2VuJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IGV4aXN0aW5nVG9rZW5zID0gJCh0aGlzKS50b2tlbmZpZWxkKCdnZXRUb2tlbnMnKTtcclxuICAgICAgICAkLmVhY2goZXhpc3RpbmdUb2tlbnMsIGZ1bmN0aW9uKGluZGV4LCB0b2tlbikge1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IGV2ZW50LmF0dHJzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbG9hZF9yZXF1aXJlbWVudChyb3dfaWR4KSB7XHJcbiAgICBpZiAocm93X2lkeCA9PT0gLTEpIHtcclxuICAgICAgICBhbGVydChcIlJlcXVpcmVtZW50IG5vdCBmb3VuZC5cIik7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IHJvdyBkYXRhXHJcbiAgICBsZXQgZGF0YSA9ICQoJyNyZXF1aXJlbWVudHNfdGFibGUnKS5EYXRhVGFibGUoKS5yb3cocm93X2lkeCkuZGF0YSgpO1xyXG5cclxuICAgIC8vIFByZXBhcmUgcmVxdWlyZW1lbnQgTW9kYWxcclxuICAgIGxldCByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50ID0gJCgnLm1vZGFsLWNvbnRlbnQnKTtcclxuICAgICQoJyNyZXF1aXJlbWVudF9tb2RhbCcpLm1vZGFsKCdzaG93Jyk7XHJcbiAgICByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdzaG93Jyk7XHJcbiAgICAkKCcjZm9ybWFsaXphdGlvbl9hY2NvcmRpb24nKS5odG1sKCcnKTtcclxuXHJcbiAgICAvLyBTZXQgYXZhaWxhYmxlIHRhZ3MuXHJcbiAgICAkKCcjcmVxdWlyZW1lbnRfdGFnX2ZpZWxkJykuZGF0YSgnYnMudG9rZW5maWVsZCcpLiRpbnB1dC5hdXRvY29tcGxldGUoe3NvdXJjZTogYXZhaWxhYmxlX3RhZ3N9KTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHJlcXVpcmVtZW50IGRhdGEgYW5kIHNldCB0aGUgbW9kYWwuXHJcbiAgICAkLmdldCggXCJhcGkvcmVxL2dldFwiLCB7IGlkOiBkYXRhWydpZCddLCByb3dfaWR4OiByb3dfaWR4IH0sIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgLy8gTWV0YSBpbmZvcm1hdGlvblxyXG4gICAgICAgICQoJyNyZXF1aXJlbWVudF9pZCcpLnZhbChkYXRhLmlkKTtcclxuICAgICAgICAkKCcjbW9kYWxfYXNzb2NpYXRlZF9yb3dfaW5kZXgnKS52YWwocm93X2lkeCk7XHJcbiAgICAgICAgYXZhaWxhYmxlX3ZhcnMgPSBkYXRhLmF2YWlsYWJsZV92YXJzO1xyXG4gICAgICAgIHR5cGVfaW5mZXJlbmNlX2Vycm9ycyA9IGRhdGEudHlwZV9pbmZlcmVuY2VfZXJyb3JzO1xyXG4gICAgICAgIHVwZGF0ZV9mdXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFZpc2libGUgaW5mb3JtYXRpb25cclxuICAgICAgICAkKCcjcmVxdWlyZW1lbnRfbW9kYWxfdGl0bGUnKS5odG1sKGRhdGEuaWQgKyAnOiAnICsgZGF0YS50eXBlKTtcclxuICAgICAgICAkKCcjZGVzY3JpcHRpb25fdGV4dGFyZWEnKS50ZXh0KGRhdGEuZGVzYyk7XHJcbiAgICAgICAgJCgnI2FkZF9ndWVzc19kZXNjcmlwdGlvbicpLnRleHQoZGF0YS5kZXNjKTtcclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hbGl6YXRpb25zXHJcbiAgICAgICAgJCgnI2Zvcm1hbGl6YXRpb25fYWNjb3JkaW9uJykuaHRtbChkYXRhLmZvcm1hbGl6YXRpb25zX2h0bWwpO1xyXG5cclxuICAgICAgICAkKCcjcmVxdWlyZW1lbnRfc2NvcGUnKS52YWwoZGF0YS5zY29wZSk7XHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X3BhdHRlcm4nKS52YWwoZGF0YS5wYXR0ZXJuKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzXHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X3RhZ19maWVsZCcpLnRva2VuZmllbGQoJ3NldFRva2VucycsIGRhdGEudGFncyk7XHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X3N0YXR1cycpLnZhbChkYXRhLnN0YXR1cyk7XHJcblxyXG4gICAgICAgIC8vIFNldCBjc3ZfZGF0YVxyXG4gICAgICAgIGxldCBjc3Zfcm93X2NvbnRlbnQgPSAkKCcjY3N2X2NvbnRlbnRfYWNjb3JkaW9uJyk7XHJcbiAgICAgICAgY3N2X3Jvd19jb250ZW50Lmh0bWwoJycpO1xyXG4gICAgICAgIGNzdl9yb3dfY29udGVudC5jb2xsYXBzZSgnaGlkZScpO1xyXG4gICAgICAgIGxldCBjc3ZfZGF0YSA9IGRhdGEuY3N2X2RhdGE7XHJcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBjc3ZfZGF0YSl7XHJcbiAgICAgICAgICAgIGlmIChjc3ZfZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3N2X2RhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgIGNzdl9yb3dfY29udGVudC5hcHBlbmQoJzxwPjxzdHJvbmc+JyArIGtleSArICc6PC9zdHJvbmc+JyArIHZhbHVlICsgJzwvcD4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBhbGVydCgnQ291bGQgTm90IGxvYWQgdGhlIFJlcXVpcmVtZW50OiAnICsgZGF0YS5lcnJvcm1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSApLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSB2aXNpYmxlIFZhcnMuXHJcbiAgICAgICAgdXBkYXRlX3ZhcnMoKTtcclxuICAgICAgICAvLyBIYW5kbGUgYXV0b2NvbXBsZXRpb24gZm9yIHZhcmlhYmxlcy5cclxuICAgICAgICBiaW5kX3Zhcl9hdXRvY29tcGxldGUoKTtcclxuICAgICAgICAvLyBVcGRhdGUgYXZhaWxhYmxlIHZhcnMgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiBvZiByZXF1aXJlbWVudCBhbmQgcGF0dGVybi5cclxuICAgICAgICBiaW5kX2V4cHJlc3Npb25fYnV0dG9ucygpO1xyXG4gICAgICAgIC8vIFByZXZlbnQgaW5zZXJ0aW5nIGEgdG9rZW4gdHdpY2Ugb24gZW50ZXJcclxuICAgICAgICBwcmV2ZW50X2RvdWJsZV90b2tlbl9pbnNlcnQoKTtcclxuICAgICAgICAkKCcjcmVxdWlyZW1lbnRfbW9kYWwnKS5kYXRhKHtcclxuICAgICAgICAgICAgJ3Vuc2F2ZWRfY2hhbmdlcyc6IGZhbHNlLFxyXG4gICAgICAgICAgICAndXBkYXRlZF9mb3JtYWxpemF0aW9uJzogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1aXJlbWVudF9tb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdoaWRlJywgdHJ1ZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJpbmQgdGhlIExpbmtzIHRvIG9wZW4gYSByZXF1aXJlbWVudCBtb2RhbC5cclxuICogSW1wbGVtZW50IEJlaGF2aW91cjpcclxuICogICogTG9hZCBhbmQgc2hvdyByZXF1aXJlbWVudCBkYXRhXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudHNfdGFibGVcclxuICovXHJcbmZ1bmN0aW9uIGJpbmRfcmVxdWlyZW1lbnRfaWRfdG9fbW9kYWxzKHJlcXVpcmVtZW50c190YWJsZSkge1xyXG4gICAgLy8gQWRkIGxpc3RlbmVyIGZvciBjbGlja3Mgb24gdGhlIFJvd3MuXHJcbiAgICAkKCcjcmVxdWlyZW1lbnRzX3RhYmxlJykuZmluZCgndGJvZHknKS5vbignY2xpY2snLCAnYScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIC8vIHByZXZlbnQgYm9keSB0byBiZSBzY3JvbGxlZCB0byB0aGUgdG9wLlxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgbGV0IHJvd19pZHggPSByZXF1aXJlbWVudHNfdGFibGUucm93KCQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKSkuaW5kZXgoKTtcclxuICAgICAgICBsb2FkX3JlcXVpcmVtZW50KHJvd19pZHgpO1xyXG4gICAgfSApO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgY29sb3Igb2YgdGhlIGNvbHVtbiB0b2dnbGUgYnV0dG9ucy5cclxuICogQ29sdW1uIHZpc2libGUgLT4gQnV0dG9uIGJsdWUgKGJ0bi1pbmZvKS5cclxuICogQ29sdW1uIG5vdCB2aXNpYmxlIC0+IEJ1dHRvbiBncmV5IChidG4tc2Vjb25kYXJ5KS5cclxuICogVXBkYXRlIHZpc2libGVfY29sdW1uc1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlX3Zpc2libGVfY29sdW1uc19pbmZvcm1hdGlvbigpIHtcclxuICAgIGxldCByZXF1aXJlbWVudHNfdGFibGUgPSAkKCcjcmVxdWlyZW1lbnRzX3RhYmxlJykuRGF0YVRhYmxlKCk7XHJcbiAgICBsZXQgbmV3X3Zpc2libGVfY29sdW1ucyA9IFtdO1xyXG4gICAgJC5lYWNoKHJlcXVpcmVtZW50c190YWJsZS5jb2x1bW5zKCkudmlzaWJsZSgpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYodmFsdWUgPT09IGZhbHNlKXtcclxuICAgICAgICAgICAgJCgnI2NvbF90b2dnbGVfYnV0dG9uXycgKyBrZXkpLnJlbW92ZUNsYXNzKCdidG4taW5mbycpLmFkZENsYXNzKCdidG4tc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgICAgIG5ld192aXNpYmxlX2NvbHVtbnMucHVzaChmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCgnI2NvbF90b2dnbGVfYnV0dG9uXycgKyBrZXkpLnJlbW92ZUNsYXNzKCdidG4tc2Vjb25kYXJ5JykuYWRkQ2xhc3MoJ2J0bi1pbmZvJyk7XHJcbiAgICAgICAgICAgIG5ld192aXNpYmxlX2NvbHVtbnMucHVzaCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZpc2libGVfY29sdW1ucyA9IG5ld192aXNpYmxlX2NvbHVtbnM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5kIHRoZSByZXF1aXJlbWVudHMgdGFibGUgbWFuaXB1bGF0b3JzIHRvIHRoZSB0YWJsZS5cclxuICogSW5pdGlhbGl6ZSBtYW5pcHVsYXRvcnMgYmVoYXZpb3VyLlxyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnRzX3RhYmxlIFRoZSByZXF1aXJlbWVudHMgdGFibGVcclxuICovXHJcbmZ1bmN0aW9uIGluaXRfZGF0YXRhYmxlX21hbmlwdWxhdG9ycyhyZXF1aXJlbWVudHNfdGFibGUpIHtcclxuICAgIC8vIEhlYWRlcnMgZXh0ZW5zaW9uOiBBZGQgaW5kZXggdG8gYWRkcmVzcyBpbiBzZWFyY2guXHJcbiAgICByZXF1aXJlbWVudHNfdGFibGUuY29sdW1ucygpLmV2ZXJ5KCBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG4gICAgICAgIGlmIChpbmRleCA+IDApIHJlcXVpcmVtZW50c190YWJsZS5jb2x1bW4oIGluZGV4ICkuaGVhZGVyKCkuYXBwZW5kKCcgKCcgKyBpbmRleCArICcpJyk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gU2F2ZSBidXR0b25cclxuICAgICQoJyNzYXZlX3JlcXVpcmVtZW50X21vZGFsJykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN0b3JlX3JlcXVpcmVtZW50KHJlcXVpcmVtZW50c190YWJsZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUYWJsZSBTZWFyY2ggcmVsYXRlZCBzdHVmZi5cclxuICAgIC8vIEJpbmQgYmlnIGN1c3RvbSBzZWFyY2hiYXIgdG8gc2VhcmNoIHRoZSB0YWJsZS5cclxuICAgICQoJyNzZWFyY2hfYmFyJykua2V5cHJlc3MoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmKGUud2hpY2ggPT09IDEzKSB7IC8vIFNlYXJjaCBvbiBlbnRlci5cclxuICAgICAgICAgICAgdXBkYXRlX3NlYXJjaCgpO1xyXG4gICAgICAgICAgICByZXF1aXJlbWVudHNfdGFibGUuZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFRhYmxlIGZpbHRlcnMuXHJcbiAgICAkKCcjdHlwZS1maWx0ZXItaW5wdXQnKS5hdXRvY29tcGxldGUoe1xyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzb3VyY2U6IGF2YWlsYWJsZV90eXBlcyxcclxuICAgICAgICBkZWxheTogMTAwXHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjc3RhdHVzLWZpbHRlci1pbnB1dCcpLmF1dG9jb21wbGV0ZSh7XHJcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxyXG4gICAgICAgIHNvdXJjZTogYXZhaWxhYmxlX3N0YXR1cyxcclxuICAgICAgICBkZWxheTogMTAwXHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjdGFnLWZpbHRlci1pbnB1dCcpLmF1dG9jb21wbGV0ZSh7XHJcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxyXG4gICAgICAgIHNvdXJjZTogYXZhaWxhYmxlX3RhZ3MsXHJcbiAgICAgICAgZGVsYXk6IDEwMFxyXG4gICAgfSk7XHJcblxyXG4gICAgJCgnI3RhZy1maWx0ZXItaW5wdXQsICNzdGF0dXMtZmlsdGVyLWlucHV0LCAjdHlwZS1maWx0ZXItaW5wdXQnKVxyXG4gICAgICAgIC5vbignZm9jdXMnLCBmdW5jdGlvbigpIHsgJCh0aGlzKS5rZXlkb3duKCk7IH0pXHJcbiAgICAgICAgLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykgeyAvLyBTZWFyY2ggb24gRW50ZXIuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVfZmlsdGVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXF1aXJlbWVudHNfdGFibGUuZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgJCgnI3RhYmxlLWZpbHRlci10b2dnbGUnKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJCgnI3RhZy1maWx0ZXItaW5wdXQnKS5hdXRvY29tcGxldGUoe3NvdXJjZTogYXZhaWxhYmxlX3RhZ3N9KTtcclxuICAgICAgICAkKCcjdHlwZS1maWx0ZXItaW5wdXQnKS5hdXRvY29tcGxldGUoe3NvdXJjZTogYXZhaWxhYmxlX3R5cGVzfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDbGVhciBhbGwgYXBwbGllZCBzZWFyY2hlcy5cclxuICAgICQoJy5jbGVhci1hbGwtZmlsdGVycycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKCcjc3RhdHVzLWZpbHRlci1pbnB1dCcpLnZhbCgnJykuZWZmZWN0KFwiaGlnaGxpZ2h0XCIsIHtjb2xvcjogJ2dyZWVuJ30sIDUwMCk7XHJcbiAgICAgICAgJCgnI3RhZy1maWx0ZXItaW5wdXQnKS52YWwoJycpLmVmZmVjdChcImhpZ2hsaWdodFwiLCB7Y29sb3I6ICdncmVlbid9LCA1MDApO1xyXG4gICAgICAgICQoJyN0eXBlLWZpbHRlci1pbnB1dCcpLnZhbCgnJykuZWZmZWN0KFwiaGlnaGxpZ2h0XCIsIHtjb2xvcjogJ2dyZWVuJ30sIDUwMCk7XHJcbiAgICAgICAgJCgnI3NlYXJjaF9iYXInKS52YWwoJycpLmVmZmVjdChcImhpZ2hsaWdodFwiLCB7Y29sb3I6ICdncmVlbid9LCA1MDApO1xyXG4gICAgICAgIHVwZGF0ZV9maWx0ZXIoKTtcclxuICAgICAgICB1cGRhdGVfc2VhcmNoKCk7XHJcbiAgICAgICAgcmVxdWlyZW1lbnRzX3RhYmxlLmRyYXcoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExpc3RlbiBmb3IgdG9vbCBzZWN0aW9uIHRyaWdnZXJzLlxyXG4gICAgJCgnI2dlbi1yZXEtZnJvbS1zZWxlY3Rpb24nKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHJlcV9pZHMgPSBbXTtcclxuICAgICAgICByZXF1aXJlbWVudHNfdGFibGUucm93cygge3NlYXJjaDonYXBwbGllZCd9ICkuZXZlcnkoIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmRhdGEoKTtcclxuICAgICAgICAgICAgcmVxX2lkcy5wdXNoKGRbJ2lkJ10pO1xyXG4gICAgICAgICB9ICk7XHJcbiAgICAgICAgJCgnI3NlbGVjdGVkX3JlcXVpcmVtZW50X2lkcycpLnZhbChKU09OLnN0cmluZ2lmeShyZXFfaWRzKSk7XHJcbiAgICAgICAgJCgnI2dlbmVyYXRlX3JlcV9mb3JtJykuc3VibWl0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjZ2VuLWNzdi1mcm9tLXNlbGVjdGlvbicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgcmVxX2lkcyA9IFtdO1xyXG4gICAgICAgIHJlcXVpcmVtZW50c190YWJsZS5yb3dzKCB7c2VhcmNoOidhcHBsaWVkJ30gKS5ldmVyeSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuZGF0YSgpO1xyXG4gICAgICAgICAgICByZXFfaWRzLnB1c2goZFsnaWQnXSk7XHJcbiAgICAgICAgIH0gKTtcclxuICAgICAgICAkKCcjc2VsZWN0ZWRfY3N2X3JlcXVpcmVtZW50X2lkcycpLnZhbChKU09OLnN0cmluZ2lmeShyZXFfaWRzKSk7XHJcbiAgICAgICAgJCgnI2dlbmVyYXRlX2Nzdl9mb3JtJykuc3VibWl0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb2x1bW4gdG9nZ2xpbmdcclxuICAgICQoJy5jb2x1bS10b2dnbGUtYnV0dG9uJykub24oICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGNvbHVtbiBBUEkgb2JqZWN0XHJcbiAgICAgICAgbGV0IGNvbHVtbiA9IHJlcXVpcmVtZW50c190YWJsZS5jb2x1bW4oJCh0aGlzKS5hdHRyKCdkYXRhLWNvbHVtbicpKTtcclxuXHJcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSB2aXNpYmlsaXR5XHJcbiAgICAgICAgY29sdW1uLnZpc2libGUoICEgY29sdW1uLnZpc2libGUoKSApO1xyXG4gICAgICAgIHVwZGF0ZV92aXNpYmxlX2NvbHVtbnNfaW5mb3JtYXRpb24oKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAkKCcucmVzZXQtY29sdW0tdG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgcmVxdWlyZW1lbnRzX3RhYmxlLmNvbHVtbnMoICcuZGVmYXVsdC1jb2wnICkudmlzaWJsZSggdHJ1ZSApO1xyXG4gICAgICAgIHJlcXVpcmVtZW50c190YWJsZS5jb2x1bW5zKCAnLmV4dHJhLWNvbCcgKS52aXNpYmxlKCBmYWxzZSApO1xyXG4gICAgICAgIHVwZGF0ZV92aXNpYmxlX2NvbHVtbnNfaW5mb3JtYXRpb24oKTtcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlX3Zpc2libGVfY29sdW1uc19pbmZvcm1hdGlvbigpO1xyXG5cclxuICAgIC8vIFNlbGVjdCByb3dzXHJcbiAgICAkKCcuc2VsZWN0LWFsbC1idXR0b24nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIC8vIFRvZ2dsZSBzZWxlY3Rpb24gb25cclxuICAgICAgICBpZiAoJCggdGhpcyApLmhhc0NsYXNzKCdidG4tc2Vjb25kYXJ5JykpIHtcclxuICAgICAgICAgICAgcmVxdWlyZW1lbnRzX3RhYmxlLnJvd3MoIHtwYWdlOidjdXJyZW50J30gKS5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIFRvZ2dsZSBzZWxlY3Rpb24gb2ZmXHJcbiAgICAgICAgICAgIHJlcXVpcmVtZW50c190YWJsZS5yb3dzKCB7cGFnZTonY3VycmVudCd9ICkuZGVzZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVG9nZ2xlIGJ1dHRvbiBzdGF0ZS5cclxuICAgICAgICAkKCcuc2VsZWN0LWFsbC1idXR0b24nKS50b2dnbGVDbGFzcygnYnRuLXNlY29uZGFyeSBidG4tcHJpbWFyeScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVG9nZ2xlIFwiU2VsZWN0IGFsbCByb3dzIHRvIGBvZmZgIG9uIHVzZXIgc3BlY2lmaWMgc2VsZWN0aW9uLlwiXHJcbiAgICByZXF1aXJlbWVudHNfdGFibGUub24oICd1c2VyLXNlbGVjdCcsIGZ1bmN0aW9uICggKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdF9idXR0b25zID0gJCgnLnNlbGVjdC1hbGwtYnV0dG9uJyk7XHJcbiAgICAgICAgc2VsZWN0X2J1dHRvbnMucmVtb3ZlQ2xhc3MoJ2J0bi1wcmltYXJ5Jyk7XHJcbiAgICAgICAgc2VsZWN0X2J1dHRvbnMuYWRkQ2xhc3MoJ2J0bi1zZWNvbmRhcnkgJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCaW5kIGF1dG9jb21wbGV0ZSBmb3IgXCJlZGl0LXNlbGVjdGVkXCIgaW5wdXRzXHJcbiAgICAkKCcjbXVsdGktYWRkLXRhZy1pbnB1dCwgI211bHRpLXJlbW92ZS10YWctaW5wdXQnKS5hdXRvY29tcGxldGUoe1xyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzb3VyY2U6IGF2YWlsYWJsZV90YWdzLFxyXG4gICAgICAgIGRlbGF5OiAxMDBcclxuICAgIH0pLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkgeyAkKHRoaXMpLmtleWRvd24oKTsgfSkudmFsKCcnKTtcclxuXHJcbiAgICAkKCcjbXVsdGktc2V0LXN0YXR1cy1pbnB1dCcpLmF1dG9jb21wbGV0ZSh7XHJcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxyXG4gICAgICAgIHNvdXJjZTogYXZhaWxhYmxlX3N0YXR1cyxcclxuICAgICAgICBkZWxheTogMTAwXHJcbiAgICB9KS5vbignZm9jdXMnLCBmdW5jdGlvbigpIHsgJCh0aGlzKS5rZXlkb3duKCk7IH0pLnZhbCgnJyk7XHJcblxyXG4gICAgJCgnLmFwcGx5LW11bHRpLWVkaXQnKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXBwbHlfbXVsdGlfZWRpdChyZXF1aXJlbWVudHNfdGFibGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJCgnLmFkZF90b3BfZ3Vlc3NfYnV0dG9uJykuY29uZmlybWF0aW9uKHtcclxuICAgICAgcm9vdFNlbGVjdG9yOiAnLmFkZF90b3BfZ3Vlc3NfYnV0dG9uJ1xyXG4gICAgfSkuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFkZF90b3BfZ3Vlc3NfdG9fc2VsZWN0ZWRfcmVxdWlyZW1lbnRzKHJlcXVpcmVtZW50c190YWJsZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIHJlcXVpcmVtZW50cyBmcm9tIGhhbmZvciBhcGkgYW5kIGJ1aWxkIHRoZSByZXF1aXJlbWVudHMgdGFibGUuXHJcbiAqIEFwcGx5IHNlYXJjaCBxdWVyaWVzIHRvIHRhYmxlXHJcbiAqIEJpbmQgYnV0dG9uL2xpbmtzIHRvIGV2ZW50cy5cclxuICogQHBhcmFtIGNvbHVtbkRlZnMgcHJlZGVmaW5lZCBjb2x1bURlZnMgKGh0dHBzOi8vZGF0YXRhYmxlcy5uZXQvcmVmZXJlbmNlL29wdGlvbi9jb2x1bW5EZWZzKVxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdF9kYXRhdGFibGUoY29sdW1uRGVmcykge1xyXG4gICAgbGV0IHJlcXVpcmVtZW50c190YWJsZSA9ICQoJyNyZXF1aXJlbWVudHNfdGFibGUnKS5EYXRhVGFibGUoe1xyXG4gICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG4gICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTG9hZGluZyBkYXRhLlwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBhZ2luZ1wiOiB0cnVlLFxyXG4gICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcbiAgICAgICAgXCJzZWxlY3RcIjoge1xyXG4gICAgICAgICAgICBzdHlsZTogICAgJ29zJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZDpmaXJzdC1jaGlsZCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicGFnZUxlbmd0aFwiOiA1MCxcclxuICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgNTAsIDEwMCwgNTAwLCAtMV0sIFsxMCwgNTAsIDEwMCwgNTAwLCBcIkFsbFwiXV0sXHJcbiAgICAgICAgXCJkb21cIjogJ3J0PFwiY29udGFpbmVyXCI8XCJyb3dcIjxcImNvbC1tZC02XCJsaT48XCJjb2wtbWQtNlwicD4+PicsXHJcbiAgICAgICAgXCJhamF4XCI6IFwiYXBpL3JlcS9nZXRzXCIsXHJcbiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlLFxyXG4gICAgICAgIFwiY29sdW1uRGVmc1wiOiBjb2x1bW5EZWZzLFxyXG4gICAgICAgIFwiY3JlYXRlZFJvd1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkYXRhSW5kZXggKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhWyd0eXBlJ10gPT09ICdIZWFkaW5nJykge1xyXG4gICAgICAgICAgICAgICAgJChyb3cpLmFkZENsYXNzKCAnYmctcHJpbWFyeScgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YVsndHlwZSddID09PSAnSW5mb3JtYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAkKHJvdykuYWRkQ2xhc3MoICd0YWJsZS1pbmZvJyApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhWyd0eXBlJ10gPT09ICdSZXF1aXJlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICQocm93KS5hZGRDbGFzcyggJ3RhYmxlLXdhcm5pbmcnICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGFbJ3R5cGUnXSA9PT0gJ25vdCBzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICAkKHJvdykuYWRkQ2xhc3MoICd0YWJsZS1saWdodCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImluZm9DYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIHByZSApIHtcclxuICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKCk7XHJcbiAgICAgICAgICAgIHZhciBwYWdlSW5mbyA9IGFwaS5wYWdlLmluZm8oKTtcclxuXHJcbiAgICAgICAgICAgICQoJyNjbGVhci1hbGwtZmlsdGVycy10ZXh0JykuaHRtbChcIlNob3dpbmcgXCIgKyB0b3RhbCArXCIvXCIrIHBhZ2VJbmZvLnJlY29yZHNUb3RhbCArIFwiLiBDbGVhciBhbGwuXCIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiU2hvd2luZyBcIiArIHN0YXJ0ICsgXCIgdG8gXCIgKyBlbmQgKyBcIiBvZiBcIiArIHRvdGFsICsgXCIgZW50cmllc1wiO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIgKGZpbHRlcmVkIGZyb20gXCIgKyBwYWdlSW5mby5yZWNvcmRzVG90YWwgKyBcIiB0b3RhbCBlbnRyaWVzKS5cIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImluaXRDb21wbGV0ZVwiIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfYmFyJykudmFsKHJlcV9zZWFyY2hfc3RyaW5nKTtcclxuICAgICAgICAgICAgJCgnI3R5cGUtZmlsdGVyLWlucHV0JykudmFsKGZpbHRlcl90eXBlX3N0cmluZyk7XHJcbiAgICAgICAgICAgICQoJyN0YWctZmlsdGVyLWlucHV0JykudmFsKGZpbHRlcl90YWdfc3RyaW5nKTtcclxuICAgICAgICAgICAgJCgnI3N0YXR1cy1maWx0ZXItaW5wdXQnKS52YWwoZmlsdGVyX3N0YXR1c19zdHJpbmcpO1xyXG5cclxuICAgICAgICAgICAgYmluZF9yZXF1aXJlbWVudF9pZF90b19tb2RhbHMocmVxdWlyZW1lbnRzX3RhYmxlKTtcclxuICAgICAgICAgICAgaW5pdF9kYXRhdGFibGVfbWFuaXB1bGF0b3JzKHJlcXVpcmVtZW50c190YWJsZSk7XHJcblxyXG4gICAgICAgICAgICBwcm9jZXNzX3VybF9xdWVyeShnZXRfcXVlcnkpO1xyXG4gICAgICAgICAgICB1cGRhdGVfc2VhcmNoKCk7XHJcbiAgICAgICAgICAgIHVwZGF0ZV9maWx0ZXIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuYWJsZSBIYW5mb3Igc3BlY2lmaWMgcmVxdWlyZW1lbnRzIHRhYmxlIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBjb250YWlucyB0aGUgcm93LiBkYXRhWzBdIGlzIHRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBjb2x1bW4gaW4gdGhlIGFjdHVhbCByb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgdG8gaW5jbHVkZSB0aGUgcm93IGludG8gdGhlIGRhdGEuIGZhbHNlIHRvIGV4Y2x1ZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlX3NlYXJjaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBpKCkuZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY29sb3IgZm9yIGEgdGFnXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRfdGFnX2NvbG9yKHRhZ19uYW1lKXtcclxuICAgIHJldHVybiB0YWdfY29sb3JzLmhhc093blByb3BlcnR5KHRhZ19uYW1lKSA/IHRhZ19jb2xvcnNbdGFnX25hbWVdIDogJyM1YmMwZGUnO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIExvYWQgYXZhaWxhYmxlIGd1ZXNzZXMgaW50byB0aGUgbW9kYWwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmZXRjaF9hdmFpbGFibGVfZ3Vlc3NlcygpIHtcclxuICAgIGxldCBtb2RhbCA9ICQoJyNyZXF1aXJlbWVudF9ndWVzc19tb2RhbCcpO1xyXG4gICAgbGV0IGF2YWlsYWJsZV9ndWVzc2VzX2NhcmRzID0gJCgnI2F2YWlsYWJsZV9ndWVzc2VzX2NhcmRzJyk7XHJcbiAgICBsZXQgbW9kYWxfY29udGVudCA9ICQoJy5tb2RhbC1jb250ZW50Jyk7XHJcbiAgICBsZXQgcmVxdWlyZW1lbnRfaWQgPSAkKCcjcmVxdWlyZW1lbnRfaWQnKS52YWwoKTtcclxuXHJcbiAgICBtb2RhbC5tb2RhbCh7XHJcbiAgICAgICAga2V5Ym9hcmQ6IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIG1vZGFsLm1vZGFsKCdzaG93Jyk7XHJcbiAgICBtb2RhbF9jb250ZW50LkxvYWRpbmdPdmVybGF5KCdzaG93Jyk7XHJcbiAgICBhdmFpbGFibGVfZ3Vlc3Nlc19jYXJkcy5odG1sKCcnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRfYXZhaWxhYmxlX2d1ZXNzKGd1ZXNzKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gJzxkaXYgaWQ9XCJhdmFpbGFibGVfZ3Vlc3Nlc19jYXJkc1wiID4nICtcclxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPicgK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGwtMSBwci0xXCI+JyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICA8cD4nK1xyXG4gICAgICAgICAgICBndWVzc1snc3RyaW5nJ10gK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgICAgICAgICAgPC9wPicgK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nICtcclxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3MgYnRuLXNtIGFkZF9ndWVzc1wiJyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJBZGQgZm9ybWFsaXphdGlvblwiJyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zY29wZT1cIicgKyBndWVzc1snc2NvcGUnXSArICdcIicgK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtcGF0dGVybj1cIicgKyBndWVzc1sncGF0dGVybiddICsgJ1wiJyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1tYXBwaW5nPVxcJycgKyBKU09OLnN0cmluZ2lmeShndWVzc1snbWFwcGluZyddKSArICdcXCc+JyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPisgQWRkIHRoaXMgZm9ybWFsaXphdGlvbiArPC9zdHJvbmc+JyArXHJcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPicgK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgIDwvZGl2PicgK1xyXG4gICAgICAgICAgICAnICAgICAgICAgICAgPC9kaXY+JztcclxuICAgICAgICBhdmFpbGFibGVfZ3Vlc3Nlc19jYXJkcy5hcHBlbmQodGVtcGxhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgICQucG9zdCggXCJhcGkvcmVxL2dldF9hdmFpbGFibGVfZ3Vlc3Nlc1wiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVxdWlyZW1lbnRfaWQ6IHJlcXVpcmVtZW50X2lkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVsnc3VjY2VzcyddID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZGF0YVsnZXJyb3Jtc2cnXSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVsnYXZhaWxhYmxlX2d1ZXNzZXMnXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZF9hdmFpbGFibGVfZ3Vlc3MoZGF0YVsnYXZhaWxhYmxlX2d1ZXNzZXMnXVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICQoJy5hZGRfZ3Vlc3MnKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFkZF9mb3JtYWxpemF0aW9uX2Zyb21fZ3Vlc3MoJCh0aGlzKS5kYXRhKCdzY29wZScpLCAkKHRoaXMpLmRhdGEoJ3BhdHRlcm4nKSwgJCh0aGlzKS5kYXRhKCdtYXBwaW5nJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vZGFsX2NvbnRlbnQuTG9hZGluZ092ZXJsYXkoJ2hpZGUnLCB0cnVlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIExvYWQgcmVxdWlyZW1lbnRzIGRhdGF0YWJsZSBkZWZpbml0aW9ucy4gVHJpZ2dlciBidWlsZCBvZiBhIGZyZXNoIHJlcXVpcmVtZW50IGRhdGF0YWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRfZGF0YXRhYmxlKCl7XHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBDb2x1bW4gZGVmcy5cclxuICAgIC8vIEZpcnN0IHNldCB0aGUgc3RhdGljIGNvbHVtIGRlZmluaXRpb25zLlxyXG4gICAgbGV0IGNvbHVtbkRlZnMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcIm9yZGVyYWJsZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgXCJjbGFzc05hbWVcIjogJ3NlbGVjdC1jaGVja2JveCcsXHJcbiAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbMF0sXHJcbiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxyXG4gICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsxXSxcclxuICAgICAgICAgICAgXCJkYXRhXCI6IFwicG9zXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsyXSxcclxuICAgICAgICAgICAgXCJkYXRhXCI6IFwiaWRcIixcclxuICAgICAgICAgICAgXCJyZW5kZXJcIjogZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJzxhIGhyZWY9XCIjXCI+JyArIGRhdGEgKyAnPC9hPic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXHJcbiAgICAgICAgICAgIFwiZGF0YVwiOiBcImRlc2NcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcInRhcmdldHNcIjogWzRdLFxyXG4gICAgICAgICAgICBcImRhdGFcIjogXCJ0eXBlXCIsXHJcbiAgICAgICAgICAgIFwicmVuZGVyXCI6IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVfdHlwZXMuaW5kZXhPZihkYXRhKSA8PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZV90eXBlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFs1XSxcclxuICAgICAgICAgICAgXCJkYXRhXCI6IFwidGFnc1wiLFxyXG4gICAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgICAgICQoZGF0YSkuZWFjaChmdW5jdGlvbiAoaWQsIHRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICcgKyBnZXRfdGFnX2NvbG9yKHRhZykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgKyAnPC9zcGFuPjwvYnI+JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRhZyB0byBhdmFpbGFibGUgdGFnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlX3RhZ3MuaW5kZXhPZih0YWcpIDw9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVfdGFncy5wdXNoKHRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3cuZm9ybWFsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzxzcGFuIGNsYXNzPVwiYmFkZ2UgYmFkZ2Utc3VjY2Vzc1wiPmhhc19mb3JtYWxpemF0aW9uPC9zcGFuPjwvYnI+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbNl0sXHJcbiAgICAgICAgICAgIFwiZGF0YVwiOiBcInN0YXR1c1wiLFxyXG4gICAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnPHNwYW4gY2xhc3M9XCJiYWRnZSBiYWRnZS1pbmZvXCI+JyArIGRhdGEgKyAnPC9zcGFuPjwvYnI+JztcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFs3XSxcclxuICAgICAgICAgICAgXCJkYXRhXCI6IFwiZm9ybWFsXCIsXHJcbiAgICAgICAgICAgIFwicmVuZGVyXCI6IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdy5mb3JtYWwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICQoZGF0YSkuZWFjaChmdW5jdGlvbiAoaWQsIGZvcm1hbGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hbGl6YXRpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc8cD4nICsgZm9ybWFsaXphdGlvbiArICc8L3A+JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbiAgICAvLyBMb2FkIGdlbmVyaWMgY29sdW1zLlxyXG4gICAgJC5nZXQoIFwiYXBpL3RhYmxlL2NvbHVtX2RlZnNcIiwgJycsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGFbJ2NvbF9kZWZzJ10ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbkRlZnMucHVzaChcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFtwYXJzZUludChkYXRhWydjb2xfZGVmcyddW2ldWyd0YXJnZXQnXSldLFxyXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGFbJ2NvbF9kZWZzJ11baV1bJ2Nzdl9uYW1lJ10sXHJcbiAgICAgICAgICAgICAgICBcInZpc2libGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlYXJjaGFibGVcIjogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaW5pdF9kYXRhdGFibGUoY29sdW1uRGVmcyk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSByZXF1aXJlbWVudCBtb2RhbCBoaWRpbmcgZXZlbnQuXHJcbiAqIFByZXZlbnQgaGlkaW5nIG9uIHVuc2F2ZWQgY2hhbmdlcyBieSBhc2tpbmcgdXNlciBmZWVkYmFjayAoZGlzY2FyZCwgc2F2ZSwgYmFjayB0byBlZGl0KS5cclxuICogQHBhcmFtIGV2ZW50IHwgdGhlIG1vZGFsIGhpZGluZyBldmVudC5cclxuICovXHJcbmZ1bmN0aW9uIG1vZGFsX2Nsb3Npbmdfcm91dGluZShldmVudCkge1xyXG4gICAgY29uc3QgdW5zYXZlZF9jaGFuZ2VzID0gJCgnI3JlcXVpcmVtZW50X21vZGFsJykuZGF0YSgndW5zYXZlZF9jaGFuZ2VzJyk7XHJcbiAgICBpZiAodW5zYXZlZF9jaGFuZ2VzID09PSB0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgZm9yY2VfY2xvc2UgPSBjb25maXJtKFwiWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLCBkbyB5b3UgcmVhbGx5IHdhbnQgdG8gY2xvc2U/XCIpO1xyXG4gICAgICAgIGlmIChmb3JjZV9jbG9zZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIHJlcXVpcmVtZW50IG1vZGFsIGJlaGF2aW91ci5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRfbW9kYWwoKSB7XHJcbiAgICBsZXQgcmVxdWlyZW1lbnRfbW9kYWwgPSAkKCcjcmVxdWlyZW1lbnRfbW9kYWwnKTtcclxuICAgIC8vIEluaXRpYWxpemUgdGFnIGF1dG9jb21wbGV0ZSBmaWxlZCBpbiB0aGUgcmVxdWlyZW1lbnRzIG1vZGFsLlxyXG4gICAgJCgnI3JlcXVpcmVtZW50X3RhZ19maWVsZCcpXHJcbiAgICAgICAgLnRva2VuZmllbGQoe1xyXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogYXZhaWxhYmxlX3RhZ3MsXHJcbiAgICAgICAgICAgICAgICBkZWxheTogMTAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNob3dBdXRvY29tcGxldGVPbkZvY3VzOiB0cnVlXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2hhbmdlKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVtZW50X21vZGFsLmRhdGEoJ3Vuc2F2ZWRfY2hhbmdlcycsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICQoJyNyZXF1aXJlbWVudF9zdGF0dXMnKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X21vZGFsJykuZGF0YSgndW5zYXZlZF9jaGFuZ2VzJywgdHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXF1aXJlbWVudF9tb2RhbC5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIG1vZGFsX2Nsb3Npbmdfcm91dGluZShldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgRVNDIGtleVxyXG4gICAgJChkb2N1bWVudCkua2V5dXAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vIElmIG1vZGFsIGlzIG9wZW4gYW5kIEVTQyBwcmVzc2VkIChFU0MgbWFwcyB0byBrZXlDb2RlIFwiMjdcIilcclxuICAgICAgICBpZiAoJCgnLm1vZGFsOnZpc2libGUnKS5sZW5ndGggJiYgZS5rZXlDb2RlID09PSAyNyl7XHJcbiAgICAgICAgICAgIGxldCBmb2N1c2VkX2lucHV0ID0gJCgnaW5wdXRbdHlwZT10ZXh0XSwgdGV4dGFyZWEsIHNlbGVjdCcpLmZpbHRlcihcIjpmb2N1c1wiKTtcclxuICAgICAgICAgICAgLy8gSWYgbm8gaW5wdXQgZWxlbWVudHMgaW4gZm9jdXMgPT4gQ2xvc2UgbW9kYWwuXHJcbiAgICAgICAgICAgIGlmIChmb2N1c2VkX2lucHV0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgaGlkZSB0aGUgYXV0b2d1ZXNzIG1vZGFsXHJcbiAgICAgICAgICAgICAgICBpZigkKCcjcmVxdWlyZW1lbnRfZ3Vlc3NfbW9kYWw6dmlzaWJsZScpLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI3JlcXVpcmVtZW50X2d1ZXNzX21vZGFsJykubW9kYWwoJ2hpZGUnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI3JlcXVpcmVtZW50X21vZGFsJykubW9kYWwoJ2hpZGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZm9jdXMgaW5wdXQgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBmb2N1c2VkX2lucHV0LmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICQoIHRoaXMgKS5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENsZWFyIHRoZSBNb2RhbCBhZnRlciBjbG9zaW5nIG1vZGFsLlxyXG4gICAgLy8gSW4gY2FzZSBvZiBzdGFja2VkIG1vZGFscyBhbmQgb24gbW9kYWwgY2xvc2luZzpcclxuICAgIC8vIFByZXZlbnQgcmVtb3ZhbCBvZiBtb2RhbC1vcGVuIGNsYXNzIGZyb20gYm9keSBpZiBhIG1vZGFsIHJlbWFpbnMuIFRoaXMgd2lsbCBrZWVwIHRoZSBzY3JvbGxiYXIgaW50YWN0LlxyXG4gICAgcmVxdWlyZW1lbnRfbW9kYWwub24oJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X3RhZ19maWVsZCcpLnZhbCgnJyk7XHJcbiAgICAgICAgJCgnI3JlcXVpcmVtZW50X3RhZ19maWVsZC10b2tlbmZpZWxkJykudmFsKCcnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExpc3RlbmVyIGZvciBhZGRpbmcgbmV3IGZvcm1hbGl6YXRpb25zLlxyXG4gICAgJCgnI2FkZF9mb3JtYWxpemF0aW9uJykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFkZF9mb3JtYWxpemF0aW9uKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMaXN0ZW5lciBmb3IgYWRkaW5nIG5ldyBnZXVzc2VkIGZvcm1hbGl6YXRpb25zLlxyXG4gICAgJCgnI2FkZF9ndXNzZWRfZm9ybWFsaXphdGlvbicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmZXRjaF9hdmFpbGFibGVfZ3Vlc3NlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJChcIi5tb2RhbFwiKS5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCQoJy5tb2RhbDp2aXNpYmxlJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygnbW9kYWwtb3BlbicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzLlxyXG4gICAgdXBkYXRlX3ZhcnMoKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2FkIHRoZSBoYW5mb3IgZnJvbnRlbmQgbWV0YSBzZXR0aW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRfbWV0YV9zZXR0aW5ncygpIHtcclxuICAgICQuZ2V0KCBcImFwaS9tZXRhL2dldFwiLCAnJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0YWdfY29sb3JzID0gZGF0YVsndGFnX2NvbG9ycyddO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogRmluZCB0aGUgZGF0YXRhYmxlIHJvdyBpbmRleCBmb3IgYSByZXF1aXJlbWVudCBieSBpdHMgcmVxdWlyZW1lbnQgaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWQgdGhlIHJlcXVpcmVtZW50IGlkLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByb3dfaW5kZXggdGhlIGRhdGF0YWJsZXMgcm93IGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0X3Jvd2lkeF9ieV9yZXFpZChyaWQpIHtcclxuICAgIGxldCByZXF1aXJlbWVudF90YWJsZSA9ICQoJyNyZXF1aXJlbWVudHNfdGFibGUnKS5EYXRhVGFibGUoKTtcclxuICAgIGxldCByZXN1bHQgPSAtMTtcclxuICAgIGxldCBmaWx0ZXJlZERhdGEgPSByZXF1aXJlbWVudF90YWJsZVxyXG4gICAgICAgIC5jb2x1bW4oIDIgKVxyXG4gICAgICAgIC5kYXRhKClcclxuICAgICAgICAuZmlsdGVyKCBmdW5jdGlvbiAoIHZhbHVlLCBpbmRleCApIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSByaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZnJlc2ggdGhlIGhhbmZvciBmcm9udGVuZCBsb2dzLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlX2xvZ3MoKSB7XHJcbiAgICAkLmdldCggXCJhcGkvbG9ncy9nZXRcIiwgJycsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgJCgnI2xvZ190ZXh0YXJlYScpLmh0bWwoZGF0YSk7XHJcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBCaW5kIGRpcmVjdCByZXF1aXJlbWVudCBsaW5rcyB0byBsb2FkIHRoZSBtb2RhbC5cclxuICAgICAgICAkKCcucmVxX2RpcmVjdF9saW5rJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbG9hZF9yZXF1aXJlbWVudChnZXRfcm93aWR4X2J5X3JlcWlkKCQodGhpcykuZGF0YShcInJpZFwiKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQoJyNsb2dfdGV4dGFyZWEnKS5zY3JvbGxUb3AoIDEwMDAwMCApO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFydCB0aGUgYXBwLlxyXG4gKi9cclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICBsb2FkX21ldGFfc2V0dGluZ3MoKTtcclxuICAgIGxvYWRfZGF0YXRhYmxlKCk7XHJcbiAgICBpbml0X21vZGFsKCk7XHJcbiAgICB1cGRhdGVfbG9ncygpO1xyXG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/requirements.js\n");

/***/ }),

/***/ "./node_modules/jquery-ui/ui/effect.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery-ui/ui/effect.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Effects 1.12.1\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Effects Core\n//>>group: Effects\n// jscs:disable maximumLineLength\n//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.\n// jscs:enable maximumLineLength\n//>>docs: http://api.jqueryui.com/category/effects-core/\n//>>demos: http://jqueryui.com/effect/\n\n( function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! ./version */ \"./node_modules/jquery-ui/ui/version.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}( function( $ ) {\n\nvar dataSpace = \"ui-effects-\",\n\tdataSpaceStyle = \"ui-effects-style\",\n\tdataSpaceAnimated = \"ui-effects-animated\",\n\n\t// Create a local jQuery because jQuery Color relies on it and the\n\t// global may not exist with AMD and a custom build (#10199)\n\tjQuery = $;\n\n$.effects = {\n\teffect: {}\n};\n\n/*!\n * jQuery Color Animations v2.1.2\n * https://github.com/jquery/jquery-color\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * Date: Wed Jan 16 08:47:09 2013 -0600\n */\n( function( jQuery, undefined ) {\n\n\tvar stepHooks = \"backgroundColor borderBottomColor borderLeftColor borderRightColor \" +\n\t\t\"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\",\n\n\t// Plusequals test for += 100 -= 100\n\trplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n\n\t// A set of RE's that can match strings and generate color tuples.\n\tstringParsers = [ {\n\t\t\tre: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ],\n\t\t\t\t\texecResult[ 2 ],\n\t\t\t\t\texecResult[ 3 ],\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ] * 2.55,\n\t\t\t\t\texecResult[ 2 ] * 2.55,\n\t\t\t\t\texecResult[ 3 ] * 2.55,\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\n\t\t\t// This regex ignores A-F because it's compared against an already lowercased string\n\t\t\tre: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\tparseInt( execResult[ 1 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 2 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 3 ], 16 )\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\n\t\t\t// This regex ignores A-F because it's compared against an already lowercased string\n\t\t\tre: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\tparseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 3 ] + execResult[ 3 ], 16 )\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tspace: \"hsla\",\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ],\n\t\t\t\t\texecResult[ 2 ] / 100,\n\t\t\t\t\texecResult[ 3 ] / 100,\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t} ],\n\n\t// JQuery.Color( )\n\tcolor = jQuery.Color = function( color, green, blue, alpha ) {\n\t\treturn new jQuery.Color.fn.parse( color, green, blue, alpha );\n\t},\n\tspaces = {\n\t\trgba: {\n\t\t\tprops: {\n\t\t\t\tred: {\n\t\t\t\t\tidx: 0,\n\t\t\t\t\ttype: \"byte\"\n\t\t\t\t},\n\t\t\t\tgreen: {\n\t\t\t\t\tidx: 1,\n\t\t\t\t\ttype: \"byte\"\n\t\t\t\t},\n\t\t\t\tblue: {\n\t\t\t\t\tidx: 2,\n\t\t\t\t\ttype: \"byte\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\thsla: {\n\t\t\tprops: {\n\t\t\t\thue: {\n\t\t\t\t\tidx: 0,\n\t\t\t\t\ttype: \"degrees\"\n\t\t\t\t},\n\t\t\t\tsaturation: {\n\t\t\t\t\tidx: 1,\n\t\t\t\t\ttype: \"percent\"\n\t\t\t\t},\n\t\t\t\tlightness: {\n\t\t\t\t\tidx: 2,\n\t\t\t\t\ttype: \"percent\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tpropTypes = {\n\t\t\"byte\": {\n\t\t\tfloor: true,\n\t\t\tmax: 255\n\t\t},\n\t\t\"percent\": {\n\t\t\tmax: 1\n\t\t},\n\t\t\"degrees\": {\n\t\t\tmod: 360,\n\t\t\tfloor: true\n\t\t}\n\t},\n\tsupport = color.support = {},\n\n\t// Element for support tests\n\tsupportElem = jQuery( \"<p>\" )[ 0 ],\n\n\t// Colors = jQuery.Color.names\n\tcolors,\n\n\t// Local aliases of functions called often\n\teach = jQuery.each;\n\n// Determine rgba support immediately\nsupportElem.style.cssText = \"background-color:rgba(1,1,1,.5)\";\nsupport.rgba = supportElem.style.backgroundColor.indexOf( \"rgba\" ) > -1;\n\n// Define cache name and alpha properties\n// for rgba and hsla spaces\neach( spaces, function( spaceName, space ) {\n\tspace.cache = \"_\" + spaceName;\n\tspace.props.alpha = {\n\t\tidx: 3,\n\t\ttype: \"percent\",\n\t\tdef: 1\n\t};\n} );\n\nfunction clamp( value, prop, allowEmpty ) {\n\tvar type = propTypes[ prop.type ] || {};\n\n\tif ( value == null ) {\n\t\treturn ( allowEmpty || !prop.def ) ? null : prop.def;\n\t}\n\n\t// ~~ is an short way of doing floor for positive numbers\n\tvalue = type.floor ? ~~value : parseFloat( value );\n\n\t// IE will pass in empty strings as value for alpha,\n\t// which will hit this case\n\tif ( isNaN( value ) ) {\n\t\treturn prop.def;\n\t}\n\n\tif ( type.mod ) {\n\n\t\t// We add mod before modding to make sure that negatives values\n\t\t// get converted properly: -10 -> 350\n\t\treturn ( value + type.mod ) % type.mod;\n\t}\n\n\t// For now all property types without mod have min and max\n\treturn 0 > value ? 0 : type.max < value ? type.max : value;\n}\n\nfunction stringParse( string ) {\n\tvar inst = color(),\n\t\trgba = inst._rgba = [];\n\n\tstring = string.toLowerCase();\n\n\teach( stringParsers, function( i, parser ) {\n\t\tvar parsed,\n\t\t\tmatch = parser.re.exec( string ),\n\t\t\tvalues = match && parser.parse( match ),\n\t\t\tspaceName = parser.space || \"rgba\";\n\n\t\tif ( values ) {\n\t\t\tparsed = inst[ spaceName ]( values );\n\n\t\t\t// If this was an rgba parse the assignment might happen twice\n\t\t\t// oh well....\n\t\t\tinst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];\n\t\t\trgba = inst._rgba = parsed._rgba;\n\n\t\t\t// Exit each( stringParsers ) here because we matched\n\t\t\treturn false;\n\t\t}\n\t} );\n\n\t// Found a stringParser that handled it\n\tif ( rgba.length ) {\n\n\t\t// If this came from a parsed string, force \"transparent\" when alpha is 0\n\t\t// chrome, (and maybe others) return \"transparent\" as rgba(0,0,0,0)\n\t\tif ( rgba.join() === \"0,0,0,0\" ) {\n\t\t\tjQuery.extend( rgba, colors.transparent );\n\t\t}\n\t\treturn inst;\n\t}\n\n\t// Named colors\n\treturn colors[ string ];\n}\n\ncolor.fn = jQuery.extend( color.prototype, {\n\tparse: function( red, green, blue, alpha ) {\n\t\tif ( red === undefined ) {\n\t\t\tthis._rgba = [ null, null, null, null ];\n\t\t\treturn this;\n\t\t}\n\t\tif ( red.jquery || red.nodeType ) {\n\t\t\tred = jQuery( red ).css( green );\n\t\t\tgreen = undefined;\n\t\t}\n\n\t\tvar inst = this,\n\t\t\ttype = jQuery.type( red ),\n\t\t\trgba = this._rgba = [];\n\n\t\t// More than 1 argument specified - assume ( red, green, blue, alpha )\n\t\tif ( green !== undefined ) {\n\t\t\tred = [ red, green, blue, alpha ];\n\t\t\ttype = \"array\";\n\t\t}\n\n\t\tif ( type === \"string\" ) {\n\t\t\treturn this.parse( stringParse( red ) || colors._default );\n\t\t}\n\n\t\tif ( type === \"array\" ) {\n\t\t\teach( spaces.rgba.props, function( key, prop ) {\n\t\t\t\trgba[ prop.idx ] = clamp( red[ prop.idx ], prop );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( type === \"object\" ) {\n\t\t\tif ( red instanceof color ) {\n\t\t\t\teach( spaces, function( spaceName, space ) {\n\t\t\t\t\tif ( red[ space.cache ] ) {\n\t\t\t\t\t\tinst[ space.cache ] = red[ space.cache ].slice();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\teach( spaces, function( spaceName, space ) {\n\t\t\t\t\tvar cache = space.cache;\n\t\t\t\t\teach( space.props, function( key, prop ) {\n\n\t\t\t\t\t\t// If the cache doesn't exist, and we know how to convert\n\t\t\t\t\t\tif ( !inst[ cache ] && space.to ) {\n\n\t\t\t\t\t\t\t// If the value was null, we don't need to copy it\n\t\t\t\t\t\t\t// if the key was alpha, we don't need to copy it either\n\t\t\t\t\t\t\tif ( key === \"alpha\" || red[ key ] == null ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinst[ cache ] = space.to( inst._rgba );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This is the only case where we allow nulls for ALL properties.\n\t\t\t\t\t\t// call clamp with alwaysAllowEmpty\n\t\t\t\t\t\tinst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Everything defined but alpha?\n\t\t\t\t\tif ( inst[ cache ] &&\n\t\t\t\t\t\t\tjQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {\n\n\t\t\t\t\t\t// Use the default of 1\n\t\t\t\t\t\tinst[ cache ][ 3 ] = 1;\n\t\t\t\t\t\tif ( space.from ) {\n\t\t\t\t\t\t\tinst._rgba = space.from( inst[ cache ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\tis: function( compare ) {\n\t\tvar is = color( compare ),\n\t\t\tsame = true,\n\t\t\tinst = this;\n\n\t\teach( spaces, function( _, space ) {\n\t\t\tvar localCache,\n\t\t\t\tisCache = is[ space.cache ];\n\t\t\tif ( isCache ) {\n\t\t\t\tlocalCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];\n\t\t\t\teach( space.props, function( _, prop ) {\n\t\t\t\t\tif ( isCache[ prop.idx ] != null ) {\n\t\t\t\t\t\tsame = ( isCache[ prop.idx ] === localCache[ prop.idx ] );\n\t\t\t\t\t\treturn same;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn same;\n\t\t} );\n\t\treturn same;\n\t},\n\t_space: function() {\n\t\tvar used = [],\n\t\t\tinst = this;\n\t\teach( spaces, function( spaceName, space ) {\n\t\t\tif ( inst[ space.cache ] ) {\n\t\t\t\tused.push( spaceName );\n\t\t\t}\n\t\t} );\n\t\treturn used.pop();\n\t},\n\ttransition: function( other, distance ) {\n\t\tvar end = color( other ),\n\t\t\tspaceName = end._space(),\n\t\t\tspace = spaces[ spaceName ],\n\t\t\tstartColor = this.alpha() === 0 ? color( \"transparent\" ) : this,\n\t\t\tstart = startColor[ space.cache ] || space.to( startColor._rgba ),\n\t\t\tresult = start.slice();\n\n\t\tend = end[ space.cache ];\n\t\teach( space.props, function( key, prop ) {\n\t\t\tvar index = prop.idx,\n\t\t\t\tstartValue = start[ index ],\n\t\t\t\tendValue = end[ index ],\n\t\t\t\ttype = propTypes[ prop.type ] || {};\n\n\t\t\t// If null, don't override start value\n\t\t\tif ( endValue === null ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If null - use end\n\t\t\tif ( startValue === null ) {\n\t\t\t\tresult[ index ] = endValue;\n\t\t\t} else {\n\t\t\t\tif ( type.mod ) {\n\t\t\t\t\tif ( endValue - startValue > type.mod / 2 ) {\n\t\t\t\t\t\tstartValue += type.mod;\n\t\t\t\t\t} else if ( startValue - endValue > type.mod / 2 ) {\n\t\t\t\t\t\tstartValue -= type.mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );\n\t\t\t}\n\t\t} );\n\t\treturn this[ spaceName ]( result );\n\t},\n\tblend: function( opaque ) {\n\n\t\t// If we are already opaque - return ourself\n\t\tif ( this._rgba[ 3 ] === 1 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar rgb = this._rgba.slice(),\n\t\t\ta = rgb.pop(),\n\t\t\tblend = color( opaque )._rgba;\n\n\t\treturn color( jQuery.map( rgb, function( v, i ) {\n\t\t\treturn ( 1 - a ) * blend[ i ] + a * v;\n\t\t} ) );\n\t},\n\ttoRgbaString: function() {\n\t\tvar prefix = \"rgba(\",\n\t\t\trgba = jQuery.map( this._rgba, function( v, i ) {\n\t\t\t\treturn v == null ? ( i > 2 ? 1 : 0 ) : v;\n\t\t\t} );\n\n\t\tif ( rgba[ 3 ] === 1 ) {\n\t\t\trgba.pop();\n\t\t\tprefix = \"rgb(\";\n\t\t}\n\n\t\treturn prefix + rgba.join() + \")\";\n\t},\n\ttoHslaString: function() {\n\t\tvar prefix = \"hsla(\",\n\t\t\thsla = jQuery.map( this.hsla(), function( v, i ) {\n\t\t\t\tif ( v == null ) {\n\t\t\t\t\tv = i > 2 ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\t// Catch 1 and 2\n\t\t\t\tif ( i && i < 3 ) {\n\t\t\t\t\tv = Math.round( v * 100 ) + \"%\";\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t} );\n\n\t\tif ( hsla[ 3 ] === 1 ) {\n\t\t\thsla.pop();\n\t\t\tprefix = \"hsl(\";\n\t\t}\n\t\treturn prefix + hsla.join() + \")\";\n\t},\n\ttoHexString: function( includeAlpha ) {\n\t\tvar rgba = this._rgba.slice(),\n\t\t\talpha = rgba.pop();\n\n\t\tif ( includeAlpha ) {\n\t\t\trgba.push( ~~( alpha * 255 ) );\n\t\t}\n\n\t\treturn \"#\" + jQuery.map( rgba, function( v ) {\n\n\t\t\t// Default to 0 when nulls exist\n\t\t\tv = ( v || 0 ).toString( 16 );\n\t\t\treturn v.length === 1 ? \"0\" + v : v;\n\t\t} ).join( \"\" );\n\t},\n\ttoString: function() {\n\t\treturn this._rgba[ 3 ] === 0 ? \"transparent\" : this.toRgbaString();\n\t}\n} );\ncolor.fn.parse.prototype = color.fn;\n\n// Hsla conversions adapted from:\n// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\nfunction hue2rgb( p, q, h ) {\n\th = ( h + 1 ) % 1;\n\tif ( h * 6 < 1 ) {\n\t\treturn p + ( q - p ) * h * 6;\n\t}\n\tif ( h * 2 < 1 ) {\n\t\treturn q;\n\t}\n\tif ( h * 3 < 2 ) {\n\t\treturn p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;\n\t}\n\treturn p;\n}\n\nspaces.hsla.to = function( rgba ) {\n\tif ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {\n\t\treturn [ null, null, null, rgba[ 3 ] ];\n\t}\n\tvar r = rgba[ 0 ] / 255,\n\t\tg = rgba[ 1 ] / 255,\n\t\tb = rgba[ 2 ] / 255,\n\t\ta = rgba[ 3 ],\n\t\tmax = Math.max( r, g, b ),\n\t\tmin = Math.min( r, g, b ),\n\t\tdiff = max - min,\n\t\tadd = max + min,\n\t\tl = add * 0.5,\n\t\th, s;\n\n\tif ( min === max ) {\n\t\th = 0;\n\t} else if ( r === max ) {\n\t\th = ( 60 * ( g - b ) / diff ) + 360;\n\t} else if ( g === max ) {\n\t\th = ( 60 * ( b - r ) / diff ) + 120;\n\t} else {\n\t\th = ( 60 * ( r - g ) / diff ) + 240;\n\t}\n\n\t// Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n\t// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n\tif ( diff === 0 ) {\n\t\ts = 0;\n\t} else if ( l <= 0.5 ) {\n\t\ts = diff / add;\n\t} else {\n\t\ts = diff / ( 2 - add );\n\t}\n\treturn [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];\n};\n\nspaces.hsla.from = function( hsla ) {\n\tif ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {\n\t\treturn [ null, null, null, hsla[ 3 ] ];\n\t}\n\tvar h = hsla[ 0 ] / 360,\n\t\ts = hsla[ 1 ],\n\t\tl = hsla[ 2 ],\n\t\ta = hsla[ 3 ],\n\t\tq = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,\n\t\tp = 2 * l - q;\n\n\treturn [\n\t\tMath.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),\n\t\tMath.round( hue2rgb( p, q, h ) * 255 ),\n\t\tMath.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),\n\t\ta\n\t];\n};\n\neach( spaces, function( spaceName, space ) {\n\tvar props = space.props,\n\t\tcache = space.cache,\n\t\tto = space.to,\n\t\tfrom = space.from;\n\n\t// Makes rgba() and hsla()\n\tcolor.fn[ spaceName ] = function( value ) {\n\n\t\t// Generate a cache for this space if it doesn't exist\n\t\tif ( to && !this[ cache ] ) {\n\t\t\tthis[ cache ] = to( this._rgba );\n\t\t}\n\t\tif ( value === undefined ) {\n\t\t\treturn this[ cache ].slice();\n\t\t}\n\n\t\tvar ret,\n\t\t\ttype = jQuery.type( value ),\n\t\t\tarr = ( type === \"array\" || type === \"object\" ) ? value : arguments,\n\t\t\tlocal = this[ cache ].slice();\n\n\t\teach( props, function( key, prop ) {\n\t\t\tvar val = arr[ type === \"object\" ? key : prop.idx ];\n\t\t\tif ( val == null ) {\n\t\t\t\tval = local[ prop.idx ];\n\t\t\t}\n\t\t\tlocal[ prop.idx ] = clamp( val, prop );\n\t\t} );\n\n\t\tif ( from ) {\n\t\t\tret = color( from( local ) );\n\t\t\tret[ cache ] = local;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn color( local );\n\t\t}\n\t};\n\n\t// Makes red() green() blue() alpha() hue() saturation() lightness()\n\teach( props, function( key, prop ) {\n\n\t\t// Alpha is included in more than one space\n\t\tif ( color.fn[ key ] ) {\n\t\t\treturn;\n\t\t}\n\t\tcolor.fn[ key ] = function( value ) {\n\t\t\tvar vtype = jQuery.type( value ),\n\t\t\t\tfn = ( key === \"alpha\" ? ( this._hsla ? \"hsla\" : \"rgba\" ) : spaceName ),\n\t\t\t\tlocal = this[ fn ](),\n\t\t\t\tcur = local[ prop.idx ],\n\t\t\t\tmatch;\n\n\t\t\tif ( vtype === \"undefined\" ) {\n\t\t\t\treturn cur;\n\t\t\t}\n\n\t\t\tif ( vtype === \"function\" ) {\n\t\t\t\tvalue = value.call( this, cur );\n\t\t\t\tvtype = jQuery.type( value );\n\t\t\t}\n\t\t\tif ( value == null && prop.empty ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( vtype === \"string\" ) {\n\t\t\t\tmatch = rplusequals.exec( value );\n\t\t\t\tif ( match ) {\n\t\t\t\t\tvalue = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === \"+\" ? 1 : -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tlocal[ prop.idx ] = value;\n\t\t\treturn this[ fn ]( local );\n\t\t};\n\t} );\n} );\n\n// Add cssHook and .fx.step function for each named hook.\n// accept a space separated string of properties\ncolor.hook = function( hook ) {\n\tvar hooks = hook.split( \" \" );\n\teach( hooks, function( i, hook ) {\n\t\tjQuery.cssHooks[ hook ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar parsed, curElem,\n\t\t\t\t\tbackgroundColor = \"\";\n\n\t\t\t\tif ( value !== \"transparent\" && ( jQuery.type( value ) !== \"string\" ||\n\t\t\t\t\t\t( parsed = stringParse( value ) ) ) ) {\n\t\t\t\t\tvalue = color( parsed || value );\n\t\t\t\t\tif ( !support.rgba && value._rgba[ 3 ] !== 1 ) {\n\t\t\t\t\t\tcurElem = hook === \"backgroundColor\" ? elem.parentNode : elem;\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t( backgroundColor === \"\" || backgroundColor === \"transparent\" ) &&\n\t\t\t\t\t\t\tcurElem && curElem.style\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbackgroundColor = jQuery.css( curElem, \"backgroundColor\" );\n\t\t\t\t\t\t\t\tcurElem = curElem.parentNode;\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = value.blend( backgroundColor && backgroundColor !== \"transparent\" ?\n\t\t\t\t\t\t\tbackgroundColor :\n\t\t\t\t\t\t\t\"_default\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = value.toRgbaString();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\telem.style[ hook ] = value;\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// Wrapped to prevent IE from throwing errors on \"invalid\" values like\n\t\t\t\t\t// 'auto' or 'inherit'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tjQuery.fx.step[ hook ] = function( fx ) {\n\t\t\tif ( !fx.colorInit ) {\n\t\t\t\tfx.start = color( fx.elem, hook );\n\t\t\t\tfx.end = color( fx.end );\n\t\t\t\tfx.colorInit = true;\n\t\t\t}\n\t\t\tjQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );\n\t\t};\n\t} );\n\n};\n\ncolor.hook( stepHooks );\n\njQuery.cssHooks.borderColor = {\n\texpand: function( value ) {\n\t\tvar expanded = {};\n\n\t\teach( [ \"Top\", \"Right\", \"Bottom\", \"Left\" ], function( i, part ) {\n\t\t\texpanded[ \"border\" + part + \"Color\" ] = value;\n\t\t} );\n\t\treturn expanded;\n\t}\n};\n\n// Basic color names only.\n// Usage of any of the other color names requires adding yourself or including\n// jquery.color.svg-names.js.\ncolors = jQuery.Color.names = {\n\n\t// 4.1. Basic color keywords\n\taqua: \"#00ffff\",\n\tblack: \"#000000\",\n\tblue: \"#0000ff\",\n\tfuchsia: \"#ff00ff\",\n\tgray: \"#808080\",\n\tgreen: \"#008000\",\n\tlime: \"#00ff00\",\n\tmaroon: \"#800000\",\n\tnavy: \"#000080\",\n\tolive: \"#808000\",\n\tpurple: \"#800080\",\n\tred: \"#ff0000\",\n\tsilver: \"#c0c0c0\",\n\tteal: \"#008080\",\n\twhite: \"#ffffff\",\n\tyellow: \"#ffff00\",\n\n\t// 4.2.3. \"transparent\" color keyword\n\ttransparent: [ null, null, null, 0 ],\n\n\t_default: \"#ffffff\"\n};\n\n} )( jQuery );\n\n/******************************************************************************/\n/****************************** CLASS ANIMATIONS ******************************/\n/******************************************************************************/\n( function() {\n\nvar classAnimationActions = [ \"add\", \"remove\", \"toggle\" ],\n\tshorthandStyles = {\n\t\tborder: 1,\n\t\tborderBottom: 1,\n\t\tborderColor: 1,\n\t\tborderLeft: 1,\n\t\tborderRight: 1,\n\t\tborderTop: 1,\n\t\tborderWidth: 1,\n\t\tmargin: 1,\n\t\tpadding: 1\n\t};\n\n$.each(\n\t[ \"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\" ],\n\tfunction( _, prop ) {\n\t\t$.fx.step[ prop ] = function( fx ) {\n\t\t\tif ( fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {\n\t\t\t\tjQuery.style( fx.elem, prop, fx.end );\n\t\t\t\tfx.setAttr = true;\n\t\t\t}\n\t\t};\n\t}\n);\n\nfunction getElementStyles( elem ) {\n\tvar key, len,\n\t\tstyle = elem.ownerDocument.defaultView ?\n\t\t\telem.ownerDocument.defaultView.getComputedStyle( elem, null ) :\n\t\t\telem.currentStyle,\n\t\tstyles = {};\n\n\tif ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {\n\t\tlen = style.length;\n\t\twhile ( len-- ) {\n\t\t\tkey = style[ len ];\n\t\t\tif ( typeof style[ key ] === \"string\" ) {\n\t\t\t\tstyles[ $.camelCase( key ) ] = style[ key ];\n\t\t\t}\n\t\t}\n\n\t// Support: Opera, IE <9\n\t} else {\n\t\tfor ( key in style ) {\n\t\t\tif ( typeof style[ key ] === \"string\" ) {\n\t\t\t\tstyles[ key ] = style[ key ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn styles;\n}\n\nfunction styleDifference( oldStyle, newStyle ) {\n\tvar diff = {},\n\t\tname, value;\n\n\tfor ( name in newStyle ) {\n\t\tvalue = newStyle[ name ];\n\t\tif ( oldStyle[ name ] !== value ) {\n\t\t\tif ( !shorthandStyles[ name ] ) {\n\t\t\t\tif ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {\n\t\t\t\t\tdiff[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn diff;\n}\n\n// Support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n$.effects.animateClass = function( value, duration, easing, callback ) {\n\tvar o = $.speed( duration, easing, callback );\n\n\treturn this.queue( function() {\n\t\tvar animated = $( this ),\n\t\t\tbaseClass = animated.attr( \"class\" ) || \"\",\n\t\t\tapplyClassChange,\n\t\t\tallAnimations = o.children ? animated.find( \"*\" ).addBack() : animated;\n\n\t\t// Map the animated objects to store the original styles.\n\t\tallAnimations = allAnimations.map( function() {\n\t\t\tvar el = $( this );\n\t\t\treturn {\n\t\t\t\tel: el,\n\t\t\t\tstart: getElementStyles( this )\n\t\t\t};\n\t\t} );\n\n\t\t// Apply class change\n\t\tapplyClassChange = function() {\n\t\t\t$.each( classAnimationActions, function( i, action ) {\n\t\t\t\tif ( value[ action ] ) {\n\t\t\t\t\tanimated[ action + \"Class\" ]( value[ action ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t\tapplyClassChange();\n\n\t\t// Map all animated objects again - calculate new styles and diff\n\t\tallAnimations = allAnimations.map( function() {\n\t\t\tthis.end = getElementStyles( this.el[ 0 ] );\n\t\t\tthis.diff = styleDifference( this.start, this.end );\n\t\t\treturn this;\n\t\t} );\n\n\t\t// Apply original class\n\t\tanimated.attr( \"class\", baseClass );\n\n\t\t// Map all animated objects again - this time collecting a promise\n\t\tallAnimations = allAnimations.map( function() {\n\t\t\tvar styleInfo = this,\n\t\t\t\tdfd = $.Deferred(),\n\t\t\t\topts = $.extend( {}, o, {\n\t\t\t\t\tqueue: false,\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tdfd.resolve( styleInfo );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\tthis.el.animate( this.diff, opts );\n\t\t\treturn dfd.promise();\n\t\t} );\n\n\t\t// Once all animations have completed:\n\t\t$.when.apply( $, allAnimations.get() ).done( function() {\n\n\t\t\t// Set the final class\n\t\t\tapplyClassChange();\n\n\t\t\t// For each animated element,\n\t\t\t// clear all css properties that were animated\n\t\t\t$.each( arguments, function() {\n\t\t\t\tvar el = this.el;\n\t\t\t\t$.each( this.diff, function( key ) {\n\t\t\t\t\tel.css( key, \"\" );\n\t\t\t\t} );\n\t\t\t} );\n\n\t\t\t// This is guarnteed to be there if you use jQuery.speed()\n\t\t\t// it also handles dequeuing the next anim...\n\t\t\to.complete.call( animated[ 0 ] );\n\t\t} );\n\t} );\n};\n\n$.fn.extend( {\n\taddClass: ( function( orig ) {\n\t\treturn function( classNames, speed, easing, callback ) {\n\t\t\treturn speed ?\n\t\t\t\t$.effects.animateClass.call( this,\n\t\t\t\t\t{ add: classNames }, speed, easing, callback ) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t} )( $.fn.addClass ),\n\n\tremoveClass: ( function( orig ) {\n\t\treturn function( classNames, speed, easing, callback ) {\n\t\t\treturn arguments.length > 1 ?\n\t\t\t\t$.effects.animateClass.call( this,\n\t\t\t\t\t{ remove: classNames }, speed, easing, callback ) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t} )( $.fn.removeClass ),\n\n\ttoggleClass: ( function( orig ) {\n\t\treturn function( classNames, force, speed, easing, callback ) {\n\t\t\tif ( typeof force === \"boolean\" || force === undefined ) {\n\t\t\t\tif ( !speed ) {\n\n\t\t\t\t\t// Without speed parameter\n\t\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t\t} else {\n\t\t\t\t\treturn $.effects.animateClass.call( this,\n\t\t\t\t\t\t( force ? { add: classNames } : { remove: classNames } ),\n\t\t\t\t\t\tspeed, easing, callback );\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Without force parameter\n\t\t\t\treturn $.effects.animateClass.call( this,\n\t\t\t\t\t{ toggle: classNames }, force, speed, easing );\n\t\t\t}\n\t\t};\n\t} )( $.fn.toggleClass ),\n\n\tswitchClass: function( remove, add, speed, easing, callback ) {\n\t\treturn $.effects.animateClass.call( this, {\n\t\t\tadd: add,\n\t\t\tremove: remove\n\t\t}, speed, easing, callback );\n\t}\n} );\n\n} )();\n\n/******************************************************************************/\n/*********************************** EFFECTS **********************************/\n/******************************************************************************/\n\n( function() {\n\nif ( $.expr && $.expr.filters && $.expr.filters.animated ) {\n\t$.expr.filters.animated = ( function( orig ) {\n\t\treturn function( elem ) {\n\t\t\treturn !!$( elem ).data( dataSpaceAnimated ) || orig( elem );\n\t\t};\n\t} )( $.expr.filters.animated );\n}\n\nif ( $.uiBackCompat !== false ) {\n\t$.extend( $.effects, {\n\n\t\t// Saves a set of properties in a data storage\n\t\tsave: function( element, set ) {\n\t\t\tvar i = 0, length = set.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( set[ i ] !== null ) {\n\t\t\t\t\telement.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Restores a set of previously saved properties from a data storage\n\t\trestore: function( element, set ) {\n\t\t\tvar val, i = 0, length = set.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( set[ i ] !== null ) {\n\t\t\t\t\tval = element.data( dataSpace + set[ i ] );\n\t\t\t\t\telement.css( set[ i ], val );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsetMode: function( el, mode ) {\n\t\t\tif ( mode === \"toggle\" ) {\n\t\t\t\tmode = el.is( \":hidden\" ) ? \"show\" : \"hide\";\n\t\t\t}\n\t\t\treturn mode;\n\t\t},\n\n\t\t// Wraps the element around a wrapper that copies position properties\n\t\tcreateWrapper: function( element ) {\n\n\t\t\t// If the element is already wrapped, return it\n\t\t\tif ( element.parent().is( \".ui-effects-wrapper\" ) ) {\n\t\t\t\treturn element.parent();\n\t\t\t}\n\n\t\t\t// Wrap the element\n\t\t\tvar props = {\n\t\t\t\t\twidth: element.outerWidth( true ),\n\t\t\t\t\theight: element.outerHeight( true ),\n\t\t\t\t\t\"float\": element.css( \"float\" )\n\t\t\t\t},\n\t\t\t\twrapper = $( \"<div></div>\" )\n\t\t\t\t\t.addClass( \"ui-effects-wrapper\" )\n\t\t\t\t\t.css( {\n\t\t\t\t\t\tfontSize: \"100%\",\n\t\t\t\t\t\tbackground: \"transparent\",\n\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\tpadding: 0\n\t\t\t\t\t} ),\n\n\t\t\t\t// Store the size in case width/height are defined in % - Fixes #5245\n\t\t\t\tsize = {\n\t\t\t\t\twidth: element.width(),\n\t\t\t\t\theight: element.height()\n\t\t\t\t},\n\t\t\t\tactive = document.activeElement;\n\n\t\t\t// Support: Firefox\n\t\t\t// Firefox incorrectly exposes anonymous content\n\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n\t\t\ttry {\n\t\t\t\tactive.id;\n\t\t\t} catch ( e ) {\n\t\t\t\tactive = document.body;\n\t\t\t}\n\n\t\t\telement.wrap( wrapper );\n\n\t\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\t\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n\t\t\t\t$( active ).trigger( \"focus\" );\n\t\t\t}\n\n\t\t\t// Hotfix for jQuery 1.4 since some change in wrap() seems to actually\n\t\t\t// lose the reference to the wrapped element\n\t\t\twrapper = element.parent();\n\n\t\t\t// Transfer positioning properties to the wrapper\n\t\t\tif ( element.css( \"position\" ) === \"static\" ) {\n\t\t\t\twrapper.css( { position: \"relative\" } );\n\t\t\t\telement.css( { position: \"relative\" } );\n\t\t\t} else {\n\t\t\t\t$.extend( props, {\n\t\t\t\t\tposition: element.css( \"position\" ),\n\t\t\t\t\tzIndex: element.css( \"z-index\" )\n\t\t\t\t} );\n\t\t\t\t$.each( [ \"top\", \"left\", \"bottom\", \"right\" ], function( i, pos ) {\n\t\t\t\t\tprops[ pos ] = element.css( pos );\n\t\t\t\t\tif ( isNaN( parseInt( props[ pos ], 10 ) ) ) {\n\t\t\t\t\t\tprops[ pos ] = \"auto\";\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\telement.css( {\n\t\t\t\t\tposition: \"relative\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: \"auto\",\n\t\t\t\t\tbottom: \"auto\"\n\t\t\t\t} );\n\t\t\t}\n\t\t\telement.css( size );\n\n\t\t\treturn wrapper.css( props ).show();\n\t\t},\n\n\t\tremoveWrapper: function( element ) {\n\t\t\tvar active = document.activeElement;\n\n\t\t\tif ( element.parent().is( \".ui-effects-wrapper\" ) ) {\n\t\t\t\telement.parent().replaceWith( element );\n\n\t\t\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\t\t\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n\t\t\t\t\t$( active ).trigger( \"focus\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}\n\t} );\n}\n\n$.extend( $.effects, {\n\tversion: \"1.12.1\",\n\n\tdefine: function( name, mode, effect ) {\n\t\tif ( !effect ) {\n\t\t\teffect = mode;\n\t\t\tmode = \"effect\";\n\t\t}\n\n\t\t$.effects.effect[ name ] = effect;\n\t\t$.effects.effect[ name ].mode = mode;\n\n\t\treturn effect;\n\t},\n\n\tscaledDimensions: function( element, percent, direction ) {\n\t\tif ( percent === 0 ) {\n\t\t\treturn {\n\t\t\t\theight: 0,\n\t\t\t\twidth: 0,\n\t\t\t\touterHeight: 0,\n\t\t\t\touterWidth: 0\n\t\t\t};\n\t\t}\n\n\t\tvar x = direction !== \"horizontal\" ? ( ( percent || 100 ) / 100 ) : 1,\n\t\t\ty = direction !== \"vertical\" ? ( ( percent || 100 ) / 100 ) : 1;\n\n\t\treturn {\n\t\t\theight: element.height() * y,\n\t\t\twidth: element.width() * x,\n\t\t\touterHeight: element.outerHeight() * y,\n\t\t\touterWidth: element.outerWidth() * x\n\t\t};\n\n\t},\n\n\tclipToBox: function( animation ) {\n\t\treturn {\n\t\t\twidth: animation.clip.right - animation.clip.left,\n\t\t\theight: animation.clip.bottom - animation.clip.top,\n\t\t\tleft: animation.clip.left,\n\t\t\ttop: animation.clip.top\n\t\t};\n\t},\n\n\t// Injects recently queued functions to be first in line (after \"inprogress\")\n\tunshift: function( element, queueLength, count ) {\n\t\tvar queue = element.queue();\n\n\t\tif ( queueLength > 1 ) {\n\t\t\tqueue.splice.apply( queue,\n\t\t\t\t[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );\n\t\t}\n\t\telement.dequeue();\n\t},\n\n\tsaveStyle: function( element ) {\n\t\telement.data( dataSpaceStyle, element[ 0 ].style.cssText );\n\t},\n\n\trestoreStyle: function( element ) {\n\t\telement[ 0 ].style.cssText = element.data( dataSpaceStyle ) || \"\";\n\t\telement.removeData( dataSpaceStyle );\n\t},\n\n\tmode: function( element, mode ) {\n\t\tvar hidden = element.is( \":hidden\" );\n\n\t\tif ( mode === \"toggle\" ) {\n\t\t\tmode = hidden ? \"show\" : \"hide\";\n\t\t}\n\t\tif ( hidden ? mode === \"hide\" : mode === \"show\" ) {\n\t\t\tmode = \"none\";\n\t\t}\n\t\treturn mode;\n\t},\n\n\t// Translates a [top,left] array into a baseline value\n\tgetBaseline: function( origin, original ) {\n\t\tvar y, x;\n\n\t\tswitch ( origin[ 0 ] ) {\n\t\tcase \"top\":\n\t\t\ty = 0;\n\t\t\tbreak;\n\t\tcase \"middle\":\n\t\t\ty = 0.5;\n\t\t\tbreak;\n\t\tcase \"bottom\":\n\t\t\ty = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ty = origin[ 0 ] / original.height;\n\t\t}\n\n\t\tswitch ( origin[ 1 ] ) {\n\t\tcase \"left\":\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase \"center\":\n\t\t\tx = 0.5;\n\t\t\tbreak;\n\t\tcase \"right\":\n\t\t\tx = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tx = origin[ 1 ] / original.width;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t},\n\n\t// Creates a placeholder element so that the original element can be made absolute\n\tcreatePlaceholder: function( element ) {\n\t\tvar placeholder,\n\t\t\tcssPosition = element.css( \"position\" ),\n\t\t\tposition = element.position();\n\n\t\t// Lock in margins first to account for form elements, which\n\t\t// will change margin if you explicitly set height\n\t\t// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380\n\t\t// Support: Safari\n\t\telement.css( {\n\t\t\tmarginTop: element.css( \"marginTop\" ),\n\t\t\tmarginBottom: element.css( \"marginBottom\" ),\n\t\t\tmarginLeft: element.css( \"marginLeft\" ),\n\t\t\tmarginRight: element.css( \"marginRight\" )\n\t\t} )\n\t\t.outerWidth( element.outerWidth() )\n\t\t.outerHeight( element.outerHeight() );\n\n\t\tif ( /^(static|relative)/.test( cssPosition ) ) {\n\t\t\tcssPosition = \"absolute\";\n\n\t\t\tplaceholder = $( \"<\" + element[ 0 ].nodeName + \">\" ).insertAfter( element ).css( {\n\n\t\t\t\t// Convert inline to inline block to account for inline elements\n\t\t\t\t// that turn to inline block based on content (like img)\n\t\t\t\tdisplay: /^(inline|ruby)/.test( element.css( \"display\" ) ) ?\n\t\t\t\t\t\"inline-block\" :\n\t\t\t\t\t\"block\",\n\t\t\t\tvisibility: \"hidden\",\n\n\t\t\t\t// Margins need to be set to account for margin collapse\n\t\t\t\tmarginTop: element.css( \"marginTop\" ),\n\t\t\t\tmarginBottom: element.css( \"marginBottom\" ),\n\t\t\t\tmarginLeft: element.css( \"marginLeft\" ),\n\t\t\t\tmarginRight: element.css( \"marginRight\" ),\n\t\t\t\t\"float\": element.css( \"float\" )\n\t\t\t} )\n\t\t\t.outerWidth( element.outerWidth() )\n\t\t\t.outerHeight( element.outerHeight() )\n\t\t\t.addClass( \"ui-effects-placeholder\" );\n\n\t\t\telement.data( dataSpace + \"placeholder\", placeholder );\n\t\t}\n\n\t\telement.css( {\n\t\t\tposition: cssPosition,\n\t\t\tleft: position.left,\n\t\t\ttop: position.top\n\t\t} );\n\n\t\treturn placeholder;\n\t},\n\n\tremovePlaceholder: function( element ) {\n\t\tvar dataKey = dataSpace + \"placeholder\",\n\t\t\t\tplaceholder = element.data( dataKey );\n\n\t\tif ( placeholder ) {\n\t\t\tplaceholder.remove();\n\t\t\telement.removeData( dataKey );\n\t\t}\n\t},\n\n\t// Removes a placeholder if it exists and restores\n\t// properties that were modified during placeholder creation\n\tcleanUp: function( element ) {\n\t\t$.effects.restoreStyle( element );\n\t\t$.effects.removePlaceholder( element );\n\t},\n\n\tsetTransition: function( element, list, factor, value ) {\n\t\tvalue = value || {};\n\t\t$.each( list, function( i, x ) {\n\t\t\tvar unit = element.cssUnit( x );\n\t\t\tif ( unit[ 0 ] > 0 ) {\n\t\t\t\tvalue[ x ] = unit[ 0 ] * factor + unit[ 1 ];\n\t\t\t}\n\t\t} );\n\t\treturn value;\n\t}\n} );\n\n// Return an effect options object for the given parameters:\nfunction _normalizeArguments( effect, options, speed, callback ) {\n\n\t// Allow passing all options as the first parameter\n\tif ( $.isPlainObject( effect ) ) {\n\t\toptions = effect;\n\t\teffect = effect.effect;\n\t}\n\n\t// Convert to an object\n\teffect = { effect: effect };\n\n\t// Catch (effect, null, ...)\n\tif ( options == null ) {\n\t\toptions = {};\n\t}\n\n\t// Catch (effect, callback)\n\tif ( $.isFunction( options ) ) {\n\t\tcallback = options;\n\t\tspeed = null;\n\t\toptions = {};\n\t}\n\n\t// Catch (effect, speed, ?)\n\tif ( typeof options === \"number\" || $.fx.speeds[ options ] ) {\n\t\tcallback = speed;\n\t\tspeed = options;\n\t\toptions = {};\n\t}\n\n\t// Catch (effect, options, callback)\n\tif ( $.isFunction( speed ) ) {\n\t\tcallback = speed;\n\t\tspeed = null;\n\t}\n\n\t// Add options to effect\n\tif ( options ) {\n\t\t$.extend( effect, options );\n\t}\n\n\tspeed = speed || options.duration;\n\teffect.duration = $.fx.off ? 0 :\n\t\ttypeof speed === \"number\" ? speed :\n\t\tspeed in $.fx.speeds ? $.fx.speeds[ speed ] :\n\t\t$.fx.speeds._default;\n\n\teffect.complete = callback || options.complete;\n\n\treturn effect;\n}\n\nfunction standardAnimationOption( option ) {\n\n\t// Valid standard speeds (nothing, number, named speed)\n\tif ( !option || typeof option === \"number\" || $.fx.speeds[ option ] ) {\n\t\treturn true;\n\t}\n\n\t// Invalid strings - treat as \"normal\" speed\n\tif ( typeof option === \"string\" && !$.effects.effect[ option ] ) {\n\t\treturn true;\n\t}\n\n\t// Complete callback\n\tif ( $.isFunction( option ) ) {\n\t\treturn true;\n\t}\n\n\t// Options hash (but not naming an effect)\n\tif ( typeof option === \"object\" && !option.effect ) {\n\t\treturn true;\n\t}\n\n\t// Didn't match any standard API\n\treturn false;\n}\n\n$.fn.extend( {\n\teffect: function( /* effect, options, speed, callback */ ) {\n\t\tvar args = _normalizeArguments.apply( this, arguments ),\n\t\t\teffectMethod = $.effects.effect[ args.effect ],\n\t\t\tdefaultMode = effectMethod.mode,\n\t\t\tqueue = args.queue,\n\t\t\tqueueName = queue || \"fx\",\n\t\t\tcomplete = args.complete,\n\t\t\tmode = args.mode,\n\t\t\tmodes = [],\n\t\t\tprefilter = function( next ) {\n\t\t\t\tvar el = $( this ),\n\t\t\t\t\tnormalizedMode = $.effects.mode( el, mode ) || defaultMode;\n\n\t\t\t\t// Sentinel for duck-punching the :animated psuedo-selector\n\t\t\t\tel.data( dataSpaceAnimated, true );\n\n\t\t\t\t// Save effect mode for later use,\n\t\t\t\t// we can't just call $.effects.mode again later,\n\t\t\t\t// as the .show() below destroys the initial state\n\t\t\t\tmodes.push( normalizedMode );\n\n\t\t\t\t// See $.uiBackCompat inside of run() for removal of defaultMode in 1.13\n\t\t\t\tif ( defaultMode && ( normalizedMode === \"show\" ||\n\t\t\t\t\t\t( normalizedMode === defaultMode && normalizedMode === \"hide\" ) ) ) {\n\t\t\t\t\tel.show();\n\t\t\t\t}\n\n\t\t\t\tif ( !defaultMode || normalizedMode !== \"none\" ) {\n\t\t\t\t\t$.effects.saveStyle( el );\n\t\t\t\t}\n\n\t\t\t\tif ( $.isFunction( next ) ) {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( $.fx.off || !effectMethod ) {\n\n\t\t\t// Delegate to the original method (e.g., .show()) if possible\n\t\t\tif ( mode ) {\n\t\t\t\treturn this[ mode ]( args.duration, complete );\n\t\t\t} else {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tif ( complete ) {\n\t\t\t\t\t\tcomplete.call( this );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction run( next ) {\n\t\t\tvar elem = $( this );\n\n\t\t\tfunction cleanup() {\n\t\t\t\telem.removeData( dataSpaceAnimated );\n\n\t\t\t\t$.effects.cleanUp( elem );\n\n\t\t\t\tif ( args.mode === \"hide\" ) {\n\t\t\t\t\telem.hide();\n\t\t\t\t}\n\n\t\t\t\tdone();\n\t\t\t}\n\n\t\t\tfunction done() {\n\t\t\t\tif ( $.isFunction( complete ) ) {\n\t\t\t\t\tcomplete.call( elem[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\tif ( $.isFunction( next ) ) {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override mode option on a per element basis,\n\t\t\t// as toggle can be either show or hide depending on element state\n\t\t\targs.mode = modes.shift();\n\n\t\t\tif ( $.uiBackCompat !== false && !defaultMode ) {\n\t\t\t\tif ( elem.is( \":hidden\" ) ? mode === \"hide\" : mode === \"show\" ) {\n\n\t\t\t\t\t// Call the core method to track \"olddisplay\" properly\n\t\t\t\t\telem[ mode ]();\n\t\t\t\t\tdone();\n\t\t\t\t} else {\n\t\t\t\t\teffectMethod.call( elem[ 0 ], args, done );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( args.mode === \"none\" ) {\n\n\t\t\t\t\t// Call the core method to track \"olddisplay\" properly\n\t\t\t\t\telem[ mode ]();\n\t\t\t\t\tdone();\n\t\t\t\t} else {\n\t\t\t\t\teffectMethod.call( elem[ 0 ], args, cleanup );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Run prefilter on all elements first to ensure that\n\t\t// any showing or hiding happens before placeholder creation,\n\t\t// which ensures that any layout changes are correctly captured.\n\t\treturn queue === false ?\n\t\t\tthis.each( prefilter ).each( run ) :\n\t\t\tthis.queue( queueName, prefilter ).queue( queueName, run );\n\t},\n\n\tshow: ( function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = \"show\";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t} )( $.fn.show ),\n\n\thide: ( function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = \"hide\";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t} )( $.fn.hide ),\n\n\ttoggle: ( function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) || typeof option === \"boolean\" ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = \"toggle\";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t} )( $.fn.toggle ),\n\n\tcssUnit: function( key ) {\n\t\tvar style = this.css( key ),\n\t\t\tval = [];\n\n\t\t$.each( [ \"em\", \"px\", \"%\", \"pt\" ], function( i, unit ) {\n\t\t\tif ( style.indexOf( unit ) > 0 ) {\n\t\t\t\tval = [ parseFloat( style ), unit ];\n\t\t\t}\n\t\t} );\n\t\treturn val;\n\t},\n\n\tcssClip: function( clipObj ) {\n\t\tif ( clipObj ) {\n\t\t\treturn this.css( \"clip\", \"rect(\" + clipObj.top + \"px \" + clipObj.right + \"px \" +\n\t\t\t\tclipObj.bottom + \"px \" + clipObj.left + \"px)\" );\n\t\t}\n\t\treturn parseClip( this.css( \"clip\" ), this );\n\t},\n\n\ttransfer: function( options, done ) {\n\t\tvar element = $( this ),\n\t\t\ttarget = $( options.to ),\n\t\t\ttargetFixed = target.css( \"position\" ) === \"fixed\",\n\t\t\tbody = $( \"body\" ),\n\t\t\tfixTop = targetFixed ? body.scrollTop() : 0,\n\t\t\tfixLeft = targetFixed ? body.scrollLeft() : 0,\n\t\t\tendPosition = target.offset(),\n\t\t\tanimation = {\n\t\t\t\ttop: endPosition.top - fixTop,\n\t\t\t\tleft: endPosition.left - fixLeft,\n\t\t\t\theight: target.innerHeight(),\n\t\t\t\twidth: target.innerWidth()\n\t\t\t},\n\t\t\tstartPosition = element.offset(),\n\t\t\ttransfer = $( \"<div class='ui-effects-transfer'></div>\" )\n\t\t\t\t.appendTo( \"body\" )\n\t\t\t\t.addClass( options.className )\n\t\t\t\t.css( {\n\t\t\t\t\ttop: startPosition.top - fixTop,\n\t\t\t\t\tleft: startPosition.left - fixLeft,\n\t\t\t\t\theight: element.innerHeight(),\n\t\t\t\t\twidth: element.innerWidth(),\n\t\t\t\t\tposition: targetFixed ? \"fixed\" : \"absolute\"\n\t\t\t\t} )\n\t\t\t\t.animate( animation, options.duration, options.easing, function() {\n\t\t\t\t\ttransfer.remove();\n\t\t\t\t\tif ( $.isFunction( done ) ) {\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t}\n} );\n\nfunction parseClip( str, element ) {\n\t\tvar outerWidth = element.outerWidth(),\n\t\t\touterHeight = element.outerHeight(),\n\t\t\tclipRegex = /^rect\\((-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto)\\)$/,\n\t\t\tvalues = clipRegex.exec( str ) || [ \"\", 0, outerWidth, outerHeight, 0 ];\n\n\t\treturn {\n\t\t\ttop: parseFloat( values[ 1 ] ) || 0,\n\t\t\tright: values[ 2 ] === \"auto\" ? outerWidth : parseFloat( values[ 2 ] ),\n\t\t\tbottom: values[ 3 ] === \"auto\" ? outerHeight : parseFloat( values[ 3 ] ),\n\t\t\tleft: parseFloat( values[ 4 ] ) || 0\n\t\t};\n}\n\n$.fx.step.clip = function( fx ) {\n\tif ( !fx.clipInit ) {\n\t\tfx.start = $( fx.elem ).cssClip();\n\t\tif ( typeof fx.end === \"string\" ) {\n\t\t\tfx.end = parseClip( fx.end, fx.elem );\n\t\t}\n\t\tfx.clipInit = true;\n\t}\n\n\t$( fx.elem ).cssClip( {\n\t\ttop: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,\n\t\tright: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,\n\t\tbottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,\n\t\tleft: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left\n\t} );\n};\n\n} )();\n\n/******************************************************************************/\n/*********************************** EASING ***********************************/\n/******************************************************************************/\n\n( function() {\n\n// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\nvar baseEasings = {};\n\n$.each( [ \"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\" ], function( i, name ) {\n\tbaseEasings[ name ] = function( p ) {\n\t\treturn Math.pow( p, i + 2 );\n\t};\n} );\n\n$.extend( baseEasings, {\n\tSine: function( p ) {\n\t\treturn 1 - Math.cos( p * Math.PI / 2 );\n\t},\n\tCirc: function( p ) {\n\t\treturn 1 - Math.sqrt( 1 - p * p );\n\t},\n\tElastic: function( p ) {\n\t\treturn p === 0 || p === 1 ? p :\n\t\t\t-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );\n\t},\n\tBack: function( p ) {\n\t\treturn p * p * ( 3 * p - 2 );\n\t},\n\tBounce: function( p ) {\n\t\tvar pow2,\n\t\t\tbounce = 4;\n\n\t\twhile ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}\n\t\treturn 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );\n\t}\n} );\n\n$.each( baseEasings, function( name, easeIn ) {\n\t$.easing[ \"easeIn\" + name ] = easeIn;\n\t$.easing[ \"easeOut\" + name ] = function( p ) {\n\t\treturn 1 - easeIn( 1 - p );\n\t};\n\t$.easing[ \"easeInOut\" + name ] = function( p ) {\n\t\treturn p < 0.5 ?\n\t\t\teaseIn( p * 2 ) / 2 :\n\t\t\t1 - easeIn( p * -2 + 2 ) / 2;\n\t};\n} );\n\n} )();\n\nreturn $.effects;\n\n} ) );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL2VmZmVjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvZWZmZWN0LmpzP2ZmY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRWZmZWN0cyBDb3JlXG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vIGpzY3M6ZGlzYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLy8+PmRlc2NyaXB0aW9uOiBFeHRlbmRzIHRoZSBpbnRlcm5hbCBqUXVlcnkgZWZmZWN0cy4gSW5jbHVkZXMgbW9ycGhpbmcgYW5kIGVhc2luZy4gUmVxdWlyZWQgYnkgYWxsIG90aGVyIGVmZmVjdHMuXG4vLyBqc2NzOmVuYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L2VmZmVjdHMtY29yZS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIsIFwiLi92ZXJzaW9uXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oIGZ1bmN0aW9uKCAkICkge1xuXG52YXIgZGF0YVNwYWNlID0gXCJ1aS1lZmZlY3RzLVwiLFxuXHRkYXRhU3BhY2VTdHlsZSA9IFwidWktZWZmZWN0cy1zdHlsZVwiLFxuXHRkYXRhU3BhY2VBbmltYXRlZCA9IFwidWktZWZmZWN0cy1hbmltYXRlZFwiLFxuXG5cdC8vIENyZWF0ZSBhIGxvY2FsIGpRdWVyeSBiZWNhdXNlIGpRdWVyeSBDb2xvciByZWxpZXMgb24gaXQgYW5kIHRoZVxuXHQvLyBnbG9iYWwgbWF5IG5vdCBleGlzdCB3aXRoIEFNRCBhbmQgYSBjdXN0b20gYnVpbGQgKCMxMDE5OSlcblx0alF1ZXJ5ID0gJDtcblxuJC5lZmZlY3RzID0ge1xuXHRlZmZlY3Q6IHt9XG59O1xuXG4vKiFcbiAqIGpRdWVyeSBDb2xvciBBbmltYXRpb25zIHYyLjEuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktY29sb3JcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogV2VkIEphbiAxNiAwODo0NzowOSAyMDEzIC0wNjAwXG4gKi9cbiggZnVuY3Rpb24oIGpRdWVyeSwgdW5kZWZpbmVkICkge1xuXG5cdHZhciBzdGVwSG9va3MgPSBcImJhY2tncm91bmRDb2xvciBib3JkZXJCb3R0b21Db2xvciBib3JkZXJMZWZ0Q29sb3IgYm9yZGVyUmlnaHRDb2xvciBcIiArXG5cdFx0XCJib3JkZXJUb3BDb2xvciBjb2xvciBjb2x1bW5SdWxlQ29sb3Igb3V0bGluZUNvbG9yIHRleHREZWNvcmF0aW9uQ29sb3IgdGV4dEVtcGhhc2lzQ29sb3JcIixcblxuXHQvLyBQbHVzZXF1YWxzIHRlc3QgZm9yICs9IDEwMCAtPSAxMDBcblx0cnBsdXNlcXVhbHMgPSAvXihbXFwtK10pPVxccyooXFxkK1xcLj9cXGQqKS8sXG5cblx0Ly8gQSBzZXQgb2YgUkUncyB0aGF0IGNhbiBtYXRjaCBzdHJpbmdzIGFuZCBnZW5lcmF0ZSBjb2xvciB0dXBsZXMuXG5cdHN0cmluZ1BhcnNlcnMgPSBbIHtcblx0XHRcdHJlOiAvcmdiYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKig/OixcXHMqKFxcZD8oPzpcXC5cXGQrKT8pXFxzKik/XFwpLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAxIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyA0IF1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRyZTogL3JnYmE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdICogMi41NSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAyIF0gKiAyLjU1LFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSAqIDIuNTUsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXG5cdFx0XHQvLyBUaGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcblx0XHRcdHJlOiAvIyhbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDEgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMiBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAzIF0sIDE2IClcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cblx0XHRcdC8vIFRoaXMgcmVnZXggaWdub3JlcyBBLUYgYmVjYXVzZSBpdCdzIGNvbXBhcmVkIGFnYWluc3QgYW4gYWxyZWFkeSBsb3dlcmNhc2VkIHN0cmluZ1xuXHRcdFx0cmU6IC8jKFthLWYwLTldKShbYS1mMC05XSkoW2EtZjAtOV0pLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMSBdICsgZXhlY1Jlc3VsdFsgMSBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAyIF0gKyBleGVjUmVzdWx0WyAyIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDMgXSArIGV4ZWNSZXN1bHRbIDMgXSwgMTYgKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdHJlOiAvaHNsYT9cXChcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKig/OixcXHMqKFxcZD8oPzpcXC5cXGQrKT8pXFxzKik/XFwpLyxcblx0XHRcdHNwYWNlOiBcImhzbGFcIixcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAxIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdIC8gMTAwLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSAvIDEwMCxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyA0IF1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9IF0sXG5cblx0Ly8gSlF1ZXJ5LkNvbG9yKCApXG5cdGNvbG9yID0galF1ZXJ5LkNvbG9yID0gZnVuY3Rpb24oIGNvbG9yLCBncmVlbiwgYmx1ZSwgYWxwaGEgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuQ29sb3IuZm4ucGFyc2UoIGNvbG9yLCBncmVlbiwgYmx1ZSwgYWxwaGEgKTtcblx0fSxcblx0c3BhY2VzID0ge1xuXHRcdHJnYmE6IHtcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdHJlZDoge1xuXHRcdFx0XHRcdGlkeDogMCxcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRncmVlbjoge1xuXHRcdFx0XHRcdGlkeDogMSxcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRibHVlOiB7XG5cdFx0XHRcdFx0aWR4OiAyLFxuXHRcdFx0XHRcdHR5cGU6IFwiYnl0ZVwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0aHNsYToge1xuXHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0aHVlOiB7XG5cdFx0XHRcdFx0aWR4OiAwLFxuXHRcdFx0XHRcdHR5cGU6IFwiZGVncmVlc1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNhdHVyYXRpb246IHtcblx0XHRcdFx0XHRpZHg6IDEsXG5cdFx0XHRcdFx0dHlwZTogXCJwZXJjZW50XCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bGlnaHRuZXNzOiB7XG5cdFx0XHRcdFx0aWR4OiAyLFxuXHRcdFx0XHRcdHR5cGU6IFwicGVyY2VudFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHByb3BUeXBlcyA9IHtcblx0XHRcImJ5dGVcIjoge1xuXHRcdFx0Zmxvb3I6IHRydWUsXG5cdFx0XHRtYXg6IDI1NVxuXHRcdH0sXG5cdFx0XCJwZXJjZW50XCI6IHtcblx0XHRcdG1heDogMVxuXHRcdH0sXG5cdFx0XCJkZWdyZWVzXCI6IHtcblx0XHRcdG1vZDogMzYwLFxuXHRcdFx0Zmxvb3I6IHRydWVcblx0XHR9XG5cdH0sXG5cdHN1cHBvcnQgPSBjb2xvci5zdXBwb3J0ID0ge30sXG5cblx0Ly8gRWxlbWVudCBmb3Igc3VwcG9ydCB0ZXN0c1xuXHRzdXBwb3J0RWxlbSA9IGpRdWVyeSggXCI8cD5cIiApWyAwIF0sXG5cblx0Ly8gQ29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzXG5cdGNvbG9ycyxcblxuXHQvLyBMb2NhbCBhbGlhc2VzIG9mIGZ1bmN0aW9ucyBjYWxsZWQgb2Z0ZW5cblx0ZWFjaCA9IGpRdWVyeS5lYWNoO1xuXG4vLyBEZXRlcm1pbmUgcmdiYSBzdXBwb3J0IGltbWVkaWF0ZWx5XG5zdXBwb3J0RWxlbS5zdHlsZS5jc3NUZXh0ID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMSwxLDEsLjUpXCI7XG5zdXBwb3J0LnJnYmEgPSBzdXBwb3J0RWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IuaW5kZXhPZiggXCJyZ2JhXCIgKSA+IC0xO1xuXG4vLyBEZWZpbmUgY2FjaGUgbmFtZSBhbmQgYWxwaGEgcHJvcGVydGllc1xuLy8gZm9yIHJnYmEgYW5kIGhzbGEgc3BhY2VzXG5lYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRzcGFjZS5jYWNoZSA9IFwiX1wiICsgc3BhY2VOYW1lO1xuXHRzcGFjZS5wcm9wcy5hbHBoYSA9IHtcblx0XHRpZHg6IDMsXG5cdFx0dHlwZTogXCJwZXJjZW50XCIsXG5cdFx0ZGVmOiAxXG5cdH07XG59ICk7XG5cbmZ1bmN0aW9uIGNsYW1wKCB2YWx1ZSwgcHJvcCwgYWxsb3dFbXB0eSApIHtcblx0dmFyIHR5cGUgPSBwcm9wVHlwZXNbIHByb3AudHlwZSBdIHx8IHt9O1xuXG5cdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gKCBhbGxvd0VtcHR5IHx8ICFwcm9wLmRlZiApID8gbnVsbCA6IHByb3AuZGVmO1xuXHR9XG5cblx0Ly8gfn4gaXMgYW4gc2hvcnQgd2F5IG9mIGRvaW5nIGZsb29yIGZvciBwb3NpdGl2ZSBudW1iZXJzXG5cdHZhbHVlID0gdHlwZS5mbG9vciA/IH5+dmFsdWUgOiBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdC8vIElFIHdpbGwgcGFzcyBpbiBlbXB0eSBzdHJpbmdzIGFzIHZhbHVlIGZvciBhbHBoYSxcblx0Ly8gd2hpY2ggd2lsbCBoaXQgdGhpcyBjYXNlXG5cdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHByb3AuZGVmO1xuXHR9XG5cblx0aWYgKCB0eXBlLm1vZCApIHtcblxuXHRcdC8vIFdlIGFkZCBtb2QgYmVmb3JlIG1vZGRpbmcgdG8gbWFrZSBzdXJlIHRoYXQgbmVnYXRpdmVzIHZhbHVlc1xuXHRcdC8vIGdldCBjb252ZXJ0ZWQgcHJvcGVybHk6IC0xMCAtPiAzNTBcblx0XHRyZXR1cm4gKCB2YWx1ZSArIHR5cGUubW9kICkgJSB0eXBlLm1vZDtcblx0fVxuXG5cdC8vIEZvciBub3cgYWxsIHByb3BlcnR5IHR5cGVzIHdpdGhvdXQgbW9kIGhhdmUgbWluIGFuZCBtYXhcblx0cmV0dXJuIDAgPiB2YWx1ZSA/IDAgOiB0eXBlLm1heCA8IHZhbHVlID8gdHlwZS5tYXggOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nUGFyc2UoIHN0cmluZyApIHtcblx0dmFyIGluc3QgPSBjb2xvcigpLFxuXHRcdHJnYmEgPSBpbnN0Ll9yZ2JhID0gW107XG5cblx0c3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cblx0ZWFjaCggc3RyaW5nUGFyc2VycywgZnVuY3Rpb24oIGksIHBhcnNlciApIHtcblx0XHR2YXIgcGFyc2VkLFxuXHRcdFx0bWF0Y2ggPSBwYXJzZXIucmUuZXhlYyggc3RyaW5nICksXG5cdFx0XHR2YWx1ZXMgPSBtYXRjaCAmJiBwYXJzZXIucGFyc2UoIG1hdGNoICksXG5cdFx0XHRzcGFjZU5hbWUgPSBwYXJzZXIuc3BhY2UgfHwgXCJyZ2JhXCI7XG5cblx0XHRpZiAoIHZhbHVlcyApIHtcblx0XHRcdHBhcnNlZCA9IGluc3RbIHNwYWNlTmFtZSBdKCB2YWx1ZXMgKTtcblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gcmdiYSBwYXJzZSB0aGUgYXNzaWdubWVudCBtaWdodCBoYXBwZW4gdHdpY2Vcblx0XHRcdC8vIG9oIHdlbGwuLi4uXG5cdFx0XHRpbnN0WyBzcGFjZXNbIHNwYWNlTmFtZSBdLmNhY2hlIF0gPSBwYXJzZWRbIHNwYWNlc1sgc3BhY2VOYW1lIF0uY2FjaGUgXTtcblx0XHRcdHJnYmEgPSBpbnN0Ll9yZ2JhID0gcGFyc2VkLl9yZ2JhO1xuXG5cdFx0XHQvLyBFeGl0IGVhY2goIHN0cmluZ1BhcnNlcnMgKSBoZXJlIGJlY2F1c2Ugd2UgbWF0Y2hlZFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEZvdW5kIGEgc3RyaW5nUGFyc2VyIHRoYXQgaGFuZGxlZCBpdFxuXHRpZiAoIHJnYmEubGVuZ3RoICkge1xuXG5cdFx0Ly8gSWYgdGhpcyBjYW1lIGZyb20gYSBwYXJzZWQgc3RyaW5nLCBmb3JjZSBcInRyYW5zcGFyZW50XCIgd2hlbiBhbHBoYSBpcyAwXG5cdFx0Ly8gY2hyb21lLCAoYW5kIG1heWJlIG90aGVycykgcmV0dXJuIFwidHJhbnNwYXJlbnRcIiBhcyByZ2JhKDAsMCwwLDApXG5cdFx0aWYgKCByZ2JhLmpvaW4oKSA9PT0gXCIwLDAsMCwwXCIgKSB7XG5cdFx0XHRqUXVlcnkuZXh0ZW5kKCByZ2JhLCBjb2xvcnMudHJhbnNwYXJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH1cblxuXHQvLyBOYW1lZCBjb2xvcnNcblx0cmV0dXJuIGNvbG9yc1sgc3RyaW5nIF07XG59XG5cbmNvbG9yLmZuID0galF1ZXJ5LmV4dGVuZCggY29sb3IucHJvdG90eXBlLCB7XG5cdHBhcnNlOiBmdW5jdGlvbiggcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgKSB7XG5cdFx0aWYgKCByZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX3JnYmEgPSBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHJlZC5qcXVlcnkgfHwgcmVkLm5vZGVUeXBlICkge1xuXHRcdFx0cmVkID0galF1ZXJ5KCByZWQgKS5jc3MoIGdyZWVuICk7XG5cdFx0XHRncmVlbiA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCA9IHRoaXMsXG5cdFx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIHJlZCApLFxuXHRcdFx0cmdiYSA9IHRoaXMuX3JnYmEgPSBbXTtcblxuXHRcdC8vIE1vcmUgdGhhbiAxIGFyZ3VtZW50IHNwZWNpZmllZCAtIGFzc3VtZSAoIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIClcblx0XHRpZiAoIGdyZWVuICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZWQgPSBbIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIF07XG5cdFx0XHR0eXBlID0gXCJhcnJheVwiO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlKCBzdHJpbmdQYXJzZSggcmVkICkgfHwgY29sb3JzLl9kZWZhdWx0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSBcImFycmF5XCIgKSB7XG5cdFx0XHRlYWNoKCBzcGFjZXMucmdiYS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHRcdFx0cmdiYVsgcHJvcC5pZHggXSA9IGNsYW1wKCByZWRbIHByb3AuaWR4IF0sIHByb3AgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdGlmICggcmVkIGluc3RhbmNlb2YgY29sb3IgKSB7XG5cdFx0XHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdFx0XHRcdFx0aWYgKCByZWRbIHNwYWNlLmNhY2hlIF0gKSB7XG5cdFx0XHRcdFx0XHRpbnN0WyBzcGFjZS5jYWNoZSBdID0gcmVkWyBzcGFjZS5jYWNoZSBdLnNsaWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSA9IHNwYWNlLmNhY2hlO1xuXHRcdFx0XHRcdGVhY2goIHNwYWNlLnByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgY2FjaGUgZG9lc24ndCBleGlzdCwgYW5kIHdlIGtub3cgaG93IHRvIGNvbnZlcnRcblx0XHRcdFx0XHRcdGlmICggIWluc3RbIGNhY2hlIF0gJiYgc3BhY2UudG8gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHZhbHVlIHdhcyBudWxsLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXRcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGtleSB3YXMgYWxwaGEsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdCBlaXRoZXJcblx0XHRcdFx0XHRcdFx0aWYgKCBrZXkgPT09IFwiYWxwaGFcIiB8fCByZWRbIGtleSBdID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGluc3RbIGNhY2hlIF0gPSBzcGFjZS50byggaW5zdC5fcmdiYSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgYWxsb3cgbnVsbHMgZm9yIEFMTCBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdFx0Ly8gY2FsbCBjbGFtcCB3aXRoIGFsd2F5c0FsbG93RW1wdHlcblx0XHRcdFx0XHRcdGluc3RbIGNhY2hlIF1bIHByb3AuaWR4IF0gPSBjbGFtcCggcmVkWyBrZXkgXSwgcHJvcCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdC8vIEV2ZXJ5dGhpbmcgZGVmaW5lZCBidXQgYWxwaGE/XG5cdFx0XHRcdFx0aWYgKCBpbnN0WyBjYWNoZSBdICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBudWxsLCBpbnN0WyBjYWNoZSBdLnNsaWNlKCAwLCAzICkgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgZGVmYXVsdCBvZiAxXG5cdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdWyAzIF0gPSAxO1xuXHRcdFx0XHRcdFx0aWYgKCBzcGFjZS5mcm9tICkge1xuXHRcdFx0XHRcdFx0XHRpbnN0Ll9yZ2JhID0gc3BhY2UuZnJvbSggaW5zdFsgY2FjaGUgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXHRpczogZnVuY3Rpb24oIGNvbXBhcmUgKSB7XG5cdFx0dmFyIGlzID0gY29sb3IoIGNvbXBhcmUgKSxcblx0XHRcdHNhbWUgPSB0cnVlLFxuXHRcdFx0aW5zdCA9IHRoaXM7XG5cblx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBfLCBzcGFjZSApIHtcblx0XHRcdHZhciBsb2NhbENhY2hlLFxuXHRcdFx0XHRpc0NhY2hlID0gaXNbIHNwYWNlLmNhY2hlIF07XG5cdFx0XHRpZiAoIGlzQ2FjaGUgKSB7XG5cdFx0XHRcdGxvY2FsQ2FjaGUgPSBpbnN0WyBzcGFjZS5jYWNoZSBdIHx8IHNwYWNlLnRvICYmIHNwYWNlLnRvKCBpbnN0Ll9yZ2JhICkgfHwgW107XG5cdFx0XHRcdGVhY2goIHNwYWNlLnByb3BzLCBmdW5jdGlvbiggXywgcHJvcCApIHtcblx0XHRcdFx0XHRpZiAoIGlzQ2FjaGVbIHByb3AuaWR4IF0gIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHNhbWUgPSAoIGlzQ2FjaGVbIHByb3AuaWR4IF0gPT09IGxvY2FsQ2FjaGVbIHByb3AuaWR4IF0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBzYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNhbWU7XG5cdFx0fSApO1xuXHRcdHJldHVybiBzYW1lO1xuXHR9LFxuXHRfc3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB1c2VkID0gW10sXG5cdFx0XHRpbnN0ID0gdGhpcztcblx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRcdFx0aWYgKCBpbnN0WyBzcGFjZS5jYWNoZSBdICkge1xuXHRcdFx0XHR1c2VkLnB1c2goIHNwYWNlTmFtZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gdXNlZC5wb3AoKTtcblx0fSxcblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oIG90aGVyLCBkaXN0YW5jZSApIHtcblx0XHR2YXIgZW5kID0gY29sb3IoIG90aGVyICksXG5cdFx0XHRzcGFjZU5hbWUgPSBlbmQuX3NwYWNlKCksXG5cdFx0XHRzcGFjZSA9IHNwYWNlc1sgc3BhY2VOYW1lIF0sXG5cdFx0XHRzdGFydENvbG9yID0gdGhpcy5hbHBoYSgpID09PSAwID8gY29sb3IoIFwidHJhbnNwYXJlbnRcIiApIDogdGhpcyxcblx0XHRcdHN0YXJ0ID0gc3RhcnRDb2xvclsgc3BhY2UuY2FjaGUgXSB8fCBzcGFjZS50byggc3RhcnRDb2xvci5fcmdiYSApLFxuXHRcdFx0cmVzdWx0ID0gc3RhcnQuc2xpY2UoKTtcblxuXHRcdGVuZCA9IGVuZFsgc3BhY2UuY2FjaGUgXTtcblx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHRcdHZhciBpbmRleCA9IHByb3AuaWR4LFxuXHRcdFx0XHRzdGFydFZhbHVlID0gc3RhcnRbIGluZGV4IF0sXG5cdFx0XHRcdGVuZFZhbHVlID0gZW5kWyBpbmRleCBdLFxuXHRcdFx0XHR0eXBlID0gcHJvcFR5cGVzWyBwcm9wLnR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgbnVsbCwgZG9uJ3Qgb3ZlcnJpZGUgc3RhcnQgdmFsdWVcblx0XHRcdGlmICggZW5kVmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbnVsbCAtIHVzZSBlbmRcblx0XHRcdGlmICggc3RhcnRWYWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmVzdWx0WyBpbmRleCBdID0gZW5kVmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHR5cGUubW9kICkge1xuXHRcdFx0XHRcdGlmICggZW5kVmFsdWUgLSBzdGFydFZhbHVlID4gdHlwZS5tb2QgLyAyICkge1xuXHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSArPSB0eXBlLm1vZDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzdGFydFZhbHVlIC0gZW5kVmFsdWUgPiB0eXBlLm1vZCAvIDIgKSB7XG5cdFx0XHRcdFx0XHRzdGFydFZhbHVlIC09IHR5cGUubW9kO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHRbIGluZGV4IF0gPSBjbGFtcCggKCBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUgKSAqIGRpc3RhbmNlICsgc3RhcnRWYWx1ZSwgcHJvcCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpc1sgc3BhY2VOYW1lIF0oIHJlc3VsdCApO1xuXHR9LFxuXHRibGVuZDogZnVuY3Rpb24oIG9wYXF1ZSApIHtcblxuXHRcdC8vIElmIHdlIGFyZSBhbHJlYWR5IG9wYXF1ZSAtIHJldHVybiBvdXJzZWxmXG5cdFx0aWYgKCB0aGlzLl9yZ2JhWyAzIF0gPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YXIgcmdiID0gdGhpcy5fcmdiYS5zbGljZSgpLFxuXHRcdFx0YSA9IHJnYi5wb3AoKSxcblx0XHRcdGJsZW5kID0gY29sb3IoIG9wYXF1ZSApLl9yZ2JhO1xuXG5cdFx0cmV0dXJuIGNvbG9yKCBqUXVlcnkubWFwKCByZ2IsIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0cmV0dXJuICggMSAtIGEgKSAqIGJsZW5kWyBpIF0gKyBhICogdjtcblx0XHR9ICkgKTtcblx0fSxcblx0dG9SZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlZml4ID0gXCJyZ2JhKFwiLFxuXHRcdFx0cmdiYSA9IGpRdWVyeS5tYXAoIHRoaXMuX3JnYmEsIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0XHRyZXR1cm4gdiA9PSBudWxsID8gKCBpID4gMiA/IDEgOiAwICkgOiB2O1xuXHRcdFx0fSApO1xuXG5cdFx0aWYgKCByZ2JhWyAzIF0gPT09IDEgKSB7XG5cdFx0XHRyZ2JhLnBvcCgpO1xuXHRcdFx0cHJlZml4ID0gXCJyZ2IoXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByZWZpeCArIHJnYmEuam9pbigpICsgXCIpXCI7XG5cdH0sXG5cdHRvSHNsYVN0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWZpeCA9IFwiaHNsYShcIixcblx0XHRcdGhzbGEgPSBqUXVlcnkubWFwKCB0aGlzLmhzbGEoKSwgZnVuY3Rpb24oIHYsIGkgKSB7XG5cdFx0XHRcdGlmICggdiA9PSBudWxsICkge1xuXHRcdFx0XHRcdHYgPSBpID4gMiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2F0Y2ggMSBhbmQgMlxuXHRcdFx0XHRpZiAoIGkgJiYgaSA8IDMgKSB7XG5cdFx0XHRcdFx0diA9IE1hdGgucm91bmQoIHYgKiAxMDAgKSArIFwiJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSApO1xuXG5cdFx0aWYgKCBoc2xhWyAzIF0gPT09IDEgKSB7XG5cdFx0XHRoc2xhLnBvcCgpO1xuXHRcdFx0cHJlZml4ID0gXCJoc2woXCI7XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXggKyBoc2xhLmpvaW4oKSArIFwiKVwiO1xuXHR9LFxuXHR0b0hleFN0cmluZzogZnVuY3Rpb24oIGluY2x1ZGVBbHBoYSApIHtcblx0XHR2YXIgcmdiYSA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcblx0XHRcdGFscGhhID0gcmdiYS5wb3AoKTtcblxuXHRcdGlmICggaW5jbHVkZUFscGhhICkge1xuXHRcdFx0cmdiYS5wdXNoKCB+figgYWxwaGEgKiAyNTUgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBcIiNcIiArIGpRdWVyeS5tYXAoIHJnYmEsIGZ1bmN0aW9uKCB2ICkge1xuXG5cdFx0XHQvLyBEZWZhdWx0IHRvIDAgd2hlbiBudWxscyBleGlzdFxuXHRcdFx0diA9ICggdiB8fCAwICkudG9TdHJpbmcoIDE2ICk7XG5cdFx0XHRyZXR1cm4gdi5sZW5ndGggPT09IDEgPyBcIjBcIiArIHYgOiB2O1xuXHRcdH0gKS5qb2luKCBcIlwiICk7XG5cdH0sXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmdiYVsgMyBdID09PSAwID8gXCJ0cmFuc3BhcmVudFwiIDogdGhpcy50b1JnYmFTdHJpbmcoKTtcblx0fVxufSApO1xuY29sb3IuZm4ucGFyc2UucHJvdG90eXBlID0gY29sb3IuZm47XG5cbi8vIEhzbGEgY29udmVyc2lvbnMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9tYWFzaGFhY2svc291cmNlL2Jyb3dzZS9wYWNrYWdlcy9ncmFwaGljcy90cnVuay9zcmMvZ3JhcGhpY3MvY29sb3JzL0hVRTJSR0IuYXM/cj01MDIxXG5cbmZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIGggKSB7XG5cdGggPSAoIGggKyAxICkgJSAxO1xuXHRpZiAoIGggKiA2IDwgMSApIHtcblx0XHRyZXR1cm4gcCArICggcSAtIHAgKSAqIGggKiA2O1xuXHR9XG5cdGlmICggaCAqIDIgPCAxICkge1xuXHRcdHJldHVybiBxO1xuXHR9XG5cdGlmICggaCAqIDMgPCAyICkge1xuXHRcdHJldHVybiBwICsgKCBxIC0gcCApICogKCAoIDIgLyAzICkgLSBoICkgKiA2O1xuXHR9XG5cdHJldHVybiBwO1xufVxuXG5zcGFjZXMuaHNsYS50byA9IGZ1bmN0aW9uKCByZ2JhICkge1xuXHRpZiAoIHJnYmFbIDAgXSA9PSBudWxsIHx8IHJnYmFbIDEgXSA9PSBudWxsIHx8IHJnYmFbIDIgXSA9PSBudWxsICkge1xuXHRcdHJldHVybiBbIG51bGwsIG51bGwsIG51bGwsIHJnYmFbIDMgXSBdO1xuXHR9XG5cdHZhciByID0gcmdiYVsgMCBdIC8gMjU1LFxuXHRcdGcgPSByZ2JhWyAxIF0gLyAyNTUsXG5cdFx0YiA9IHJnYmFbIDIgXSAvIDI1NSxcblx0XHRhID0gcmdiYVsgMyBdLFxuXHRcdG1heCA9IE1hdGgubWF4KCByLCBnLCBiICksXG5cdFx0bWluID0gTWF0aC5taW4oIHIsIGcsIGIgKSxcblx0XHRkaWZmID0gbWF4IC0gbWluLFxuXHRcdGFkZCA9IG1heCArIG1pbixcblx0XHRsID0gYWRkICogMC41LFxuXHRcdGgsIHM7XG5cblx0aWYgKCBtaW4gPT09IG1heCApIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmICggciA9PT0gbWF4ICkge1xuXHRcdGggPSAoIDYwICogKCBnIC0gYiApIC8gZGlmZiApICsgMzYwO1xuXHR9IGVsc2UgaWYgKCBnID09PSBtYXggKSB7XG5cdFx0aCA9ICggNjAgKiAoIGIgLSByICkgLyBkaWZmICkgKyAxMjA7XG5cdH0gZWxzZSB7XG5cdFx0aCA9ICggNjAgKiAoIHIgLSBnICkgLyBkaWZmICkgKyAyNDA7XG5cdH1cblxuXHQvLyBDaHJvbWEgKGRpZmYpID09IDAgbWVhbnMgZ3JleXNjYWxlIHdoaWNoLCBieSBkZWZpbml0aW9uLCBzYXR1cmF0aW9uID0gMCVcblx0Ly8gb3RoZXJ3aXNlLCBzYXR1cmF0aW9uIGlzIGJhc2VkIG9uIHRoZSByYXRpbyBvZiBjaHJvbWEgKGRpZmYpIHRvIGxpZ2h0bmVzcyAoYWRkKVxuXHRpZiAoIGRpZmYgPT09IDAgKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAoIGwgPD0gMC41ICkge1xuXHRcdHMgPSBkaWZmIC8gYWRkO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkaWZmIC8gKCAyIC0gYWRkICk7XG5cdH1cblx0cmV0dXJuIFsgTWF0aC5yb3VuZCggaCApICUgMzYwLCBzLCBsLCBhID09IG51bGwgPyAxIDogYSBdO1xufTtcblxuc3BhY2VzLmhzbGEuZnJvbSA9IGZ1bmN0aW9uKCBoc2xhICkge1xuXHRpZiAoIGhzbGFbIDAgXSA9PSBudWxsIHx8IGhzbGFbIDEgXSA9PSBudWxsIHx8IGhzbGFbIDIgXSA9PSBudWxsICkge1xuXHRcdHJldHVybiBbIG51bGwsIG51bGwsIG51bGwsIGhzbGFbIDMgXSBdO1xuXHR9XG5cdHZhciBoID0gaHNsYVsgMCBdIC8gMzYwLFxuXHRcdHMgPSBoc2xhWyAxIF0sXG5cdFx0bCA9IGhzbGFbIDIgXSxcblx0XHRhID0gaHNsYVsgMyBdLFxuXHRcdHEgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtIGwgKiBzLFxuXHRcdHAgPSAyICogbCAtIHE7XG5cblx0cmV0dXJuIFtcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoICsgKCAxIC8gMyApICkgKiAyNTUgKSxcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoICkgKiAyNTUgKSxcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoIC0gKCAxIC8gMyApICkgKiAyNTUgKSxcblx0XHRhXG5cdF07XG59O1xuXG5lYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHR2YXIgcHJvcHMgPSBzcGFjZS5wcm9wcyxcblx0XHRjYWNoZSA9IHNwYWNlLmNhY2hlLFxuXHRcdHRvID0gc3BhY2UudG8sXG5cdFx0ZnJvbSA9IHNwYWNlLmZyb207XG5cblx0Ly8gTWFrZXMgcmdiYSgpIGFuZCBoc2xhKClcblx0Y29sb3IuZm5bIHNwYWNlTmFtZSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBjYWNoZSBmb3IgdGhpcyBzcGFjZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0aWYgKCB0byAmJiAhdGhpc1sgY2FjaGUgXSApIHtcblx0XHRcdHRoaXNbIGNhY2hlIF0gPSB0byggdGhpcy5fcmdiYSApO1xuXHRcdH1cblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGUgXS5zbGljZSgpO1xuXHRcdH1cblxuXHRcdHZhciByZXQsXG5cdFx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG5cdFx0XHRhcnIgPSAoIHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm9iamVjdFwiICkgPyB2YWx1ZSA6IGFyZ3VtZW50cyxcblx0XHRcdGxvY2FsID0gdGhpc1sgY2FjaGUgXS5zbGljZSgpO1xuXG5cdFx0ZWFjaCggcHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHR2YXIgdmFsID0gYXJyWyB0eXBlID09PSBcIm9iamVjdFwiID8ga2V5IDogcHJvcC5pZHggXTtcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IGxvY2FsWyBwcm9wLmlkeCBdO1xuXHRcdFx0fVxuXHRcdFx0bG9jYWxbIHByb3AuaWR4IF0gPSBjbGFtcCggdmFsLCBwcm9wICk7XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBmcm9tICkge1xuXHRcdFx0cmV0ID0gY29sb3IoIGZyb20oIGxvY2FsICkgKTtcblx0XHRcdHJldFsgY2FjaGUgXSA9IGxvY2FsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbG9yKCBsb2NhbCApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBNYWtlcyByZWQoKSBncmVlbigpIGJsdWUoKSBhbHBoYSgpIGh1ZSgpIHNhdHVyYXRpb24oKSBsaWdodG5lc3MoKVxuXHRlYWNoKCBwcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblxuXHRcdC8vIEFscGhhIGlzIGluY2x1ZGVkIGluIG1vcmUgdGhhbiBvbmUgc3BhY2Vcblx0XHRpZiAoIGNvbG9yLmZuWyBrZXkgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29sb3IuZm5bIGtleSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG5cdFx0XHRcdGZuID0gKCBrZXkgPT09IFwiYWxwaGFcIiA/ICggdGhpcy5faHNsYSA/IFwiaHNsYVwiIDogXCJyZ2JhXCIgKSA6IHNwYWNlTmFtZSApLFxuXHRcdFx0XHRsb2NhbCA9IHRoaXNbIGZuIF0oKSxcblx0XHRcdFx0Y3VyID0gbG9jYWxbIHByb3AuaWR4IF0sXG5cdFx0XHRcdG1hdGNoO1xuXG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuY2FsbCggdGhpcywgY3VyICk7XG5cdFx0XHRcdHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgJiYgcHJvcC5lbXB0eSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRtYXRjaCA9IHJwbHVzZXF1YWxzLmV4ZWMoIHZhbHVlICk7XG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjdXIgKyBwYXJzZUZsb2F0KCBtYXRjaFsgMiBdICkgKiAoIG1hdGNoWyAxIF0gPT09IFwiK1wiID8gMSA6IC0xICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxvY2FsWyBwcm9wLmlkeCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpc1sgZm4gXSggbG9jYWwgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cbi8vIEFkZCBjc3NIb29rIGFuZCAuZnguc3RlcCBmdW5jdGlvbiBmb3IgZWFjaCBuYW1lZCBob29rLlxuLy8gYWNjZXB0IGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBwcm9wZXJ0aWVzXG5jb2xvci5ob29rID0gZnVuY3Rpb24oIGhvb2sgKSB7XG5cdHZhciBob29rcyA9IGhvb2suc3BsaXQoIFwiIFwiICk7XG5cdGVhY2goIGhvb2tzLCBmdW5jdGlvbiggaSwgaG9vayApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIGhvb2sgXSA9IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgcGFyc2VkLCBjdXJFbGVtLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IFwiXCI7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gXCJ0cmFuc3BhcmVudFwiICYmICggalF1ZXJ5LnR5cGUoIHZhbHVlICkgIT09IFwic3RyaW5nXCIgfHxcblx0XHRcdFx0XHRcdCggcGFyc2VkID0gc3RyaW5nUGFyc2UoIHZhbHVlICkgKSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29sb3IoIHBhcnNlZCB8fCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggIXN1cHBvcnQucmdiYSAmJiB2YWx1ZS5fcmdiYVsgMyBdICE9PSAxICkge1xuXHRcdFx0XHRcdFx0Y3VyRWxlbSA9IGhvb2sgPT09IFwiYmFja2dyb3VuZENvbG9yXCIgPyBlbGVtLnBhcmVudE5vZGUgOiBlbGVtO1xuXHRcdFx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdFx0XHQoIGJhY2tncm91bmRDb2xvciA9PT0gXCJcIiB8fCBiYWNrZ3JvdW5kQ29sb3IgPT09IFwidHJhbnNwYXJlbnRcIiApICYmXG5cdFx0XHRcdFx0XHRcdGN1ckVsZW0gJiYgY3VyRWxlbS5zdHlsZVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0galF1ZXJ5LmNzcyggY3VyRWxlbSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdGN1ckVsZW0gPSBjdXJFbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuYmxlbmQoIGJhY2tncm91bmRDb2xvciAmJiBiYWNrZ3JvdW5kQ29sb3IgIT09IFwidHJhbnNwYXJlbnRcIiA/XG5cdFx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvciA6XG5cdFx0XHRcdFx0XHRcdFwiX2RlZmF1bHRcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUudG9SZ2JhU3RyaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlWyBob29rIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgb24gXCJpbnZhbGlkXCIgdmFsdWVzIGxpa2Vcblx0XHRcdFx0XHQvLyAnYXV0bycgb3IgJ2luaGVyaXQnXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGpRdWVyeS5meC5zdGVwWyBob29rIF0gPSBmdW5jdGlvbiggZnggKSB7XG5cdFx0XHRpZiAoICFmeC5jb2xvckluaXQgKSB7XG5cdFx0XHRcdGZ4LnN0YXJ0ID0gY29sb3IoIGZ4LmVsZW0sIGhvb2sgKTtcblx0XHRcdFx0ZnguZW5kID0gY29sb3IoIGZ4LmVuZCApO1xuXHRcdFx0XHRmeC5jb2xvckluaXQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyBob29rIF0uc2V0KCBmeC5lbGVtLCBmeC5zdGFydC50cmFuc2l0aW9uKCBmeC5lbmQsIGZ4LnBvcyApICk7XG5cdFx0fTtcblx0fSApO1xuXG59O1xuXG5jb2xvci5ob29rKCBzdGVwSG9va3MgKTtcblxualF1ZXJ5LmNzc0hvb2tzLmJvcmRlckNvbG9yID0ge1xuXHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgZXhwYW5kZWQgPSB7fTtcblxuXHRcdGVhY2goIFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcGFydCApIHtcblx0XHRcdGV4cGFuZGVkWyBcImJvcmRlclwiICsgcGFydCArIFwiQ29sb3JcIiBdID0gdmFsdWU7XG5cdFx0fSApO1xuXHRcdHJldHVybiBleHBhbmRlZDtcblx0fVxufTtcblxuLy8gQmFzaWMgY29sb3IgbmFtZXMgb25seS5cbi8vIFVzYWdlIG9mIGFueSBvZiB0aGUgb3RoZXIgY29sb3IgbmFtZXMgcmVxdWlyZXMgYWRkaW5nIHlvdXJzZWxmIG9yIGluY2x1ZGluZ1xuLy8ganF1ZXJ5LmNvbG9yLnN2Zy1uYW1lcy5qcy5cbmNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lcyA9IHtcblxuXHQvLyA0LjEuIEJhc2ljIGNvbG9yIGtleXdvcmRzXG5cdGFxdWE6IFwiIzAwZmZmZlwiLFxuXHRibGFjazogXCIjMDAwMDAwXCIsXG5cdGJsdWU6IFwiIzAwMDBmZlwiLFxuXHRmdWNoc2lhOiBcIiNmZjAwZmZcIixcblx0Z3JheTogXCIjODA4MDgwXCIsXG5cdGdyZWVuOiBcIiMwMDgwMDBcIixcblx0bGltZTogXCIjMDBmZjAwXCIsXG5cdG1hcm9vbjogXCIjODAwMDAwXCIsXG5cdG5hdnk6IFwiIzAwMDA4MFwiLFxuXHRvbGl2ZTogXCIjODA4MDAwXCIsXG5cdHB1cnBsZTogXCIjODAwMDgwXCIsXG5cdHJlZDogXCIjZmYwMDAwXCIsXG5cdHNpbHZlcjogXCIjYzBjMGMwXCIsXG5cdHRlYWw6IFwiIzAwODA4MFwiLFxuXHR3aGl0ZTogXCIjZmZmZmZmXCIsXG5cdHllbGxvdzogXCIjZmZmZjAwXCIsXG5cblx0Ly8gNC4yLjMuIFwidHJhbnNwYXJlbnRcIiBjb2xvciBrZXl3b3JkXG5cdHRyYW5zcGFyZW50OiBbIG51bGwsIG51bGwsIG51bGwsIDAgXSxcblxuXHRfZGVmYXVsdDogXCIjZmZmZmZmXCJcbn07XG5cbn0gKSggalF1ZXJ5ICk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIENMQVNTIEFOSU1BVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiggZnVuY3Rpb24oKSB7XG5cbnZhciBjbGFzc0FuaW1hdGlvbkFjdGlvbnMgPSBbIFwiYWRkXCIsIFwicmVtb3ZlXCIsIFwidG9nZ2xlXCIgXSxcblx0c2hvcnRoYW5kU3R5bGVzID0ge1xuXHRcdGJvcmRlcjogMSxcblx0XHRib3JkZXJCb3R0b206IDEsXG5cdFx0Ym9yZGVyQ29sb3I6IDEsXG5cdFx0Ym9yZGVyTGVmdDogMSxcblx0XHRib3JkZXJSaWdodDogMSxcblx0XHRib3JkZXJUb3A6IDEsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0bWFyZ2luOiAxLFxuXHRcdHBhZGRpbmc6IDFcblx0fTtcblxuJC5lYWNoKFxuXHRbIFwiYm9yZGVyTGVmdFN0eWxlXCIsIFwiYm9yZGVyUmlnaHRTdHlsZVwiLCBcImJvcmRlckJvdHRvbVN0eWxlXCIsIFwiYm9yZGVyVG9wU3R5bGVcIiBdLFxuXHRmdW5jdGlvbiggXywgcHJvcCApIHtcblx0XHQkLmZ4LnN0ZXBbIHByb3AgXSA9IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRcdGlmICggZnguZW5kICE9PSBcIm5vbmVcIiAmJiAhZnguc2V0QXR0ciB8fCBmeC5wb3MgPT09IDEgJiYgIWZ4LnNldEF0dHIgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgcHJvcCwgZnguZW5kICk7XG5cdFx0XHRcdGZ4LnNldEF0dHIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbik7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRTdHlsZXMoIGVsZW0gKSB7XG5cdHZhciBrZXksIGxlbixcblx0XHRzdHlsZSA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA/XG5cdFx0XHRlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApIDpcblx0XHRcdGVsZW0uY3VycmVudFN0eWxlLFxuXHRcdHN0eWxlcyA9IHt9O1xuXG5cdGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoICYmIHN0eWxlWyAwIF0gJiYgc3R5bGVbIHN0eWxlWyAwIF0gXSApIHtcblx0XHRsZW4gPSBzdHlsZS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBsZW4tLSApIHtcblx0XHRcdGtleSA9IHN0eWxlWyBsZW4gXTtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlWyBrZXkgXSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0c3R5bGVzWyAkLmNhbWVsQ2FzZSgga2V5ICkgXSA9IHN0eWxlWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEsIElFIDw5XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICgga2V5IGluIHN0eWxlICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRzdHlsZXNbIGtleSBdID0gc3R5bGVbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIHN0eWxlRGlmZmVyZW5jZSggb2xkU3R5bGUsIG5ld1N0eWxlICkge1xuXHR2YXIgZGlmZiA9IHt9LFxuXHRcdG5hbWUsIHZhbHVlO1xuXG5cdGZvciAoIG5hbWUgaW4gbmV3U3R5bGUgKSB7XG5cdFx0dmFsdWUgPSBuZXdTdHlsZVsgbmFtZSBdO1xuXHRcdGlmICggb2xkU3R5bGVbIG5hbWUgXSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRpZiAoICFzaG9ydGhhbmRTdHlsZXNbIG5hbWUgXSApIHtcblx0XHRcdFx0aWYgKCAkLmZ4LnN0ZXBbIG5hbWUgXSB8fCAhaXNOYU4oIHBhcnNlRmxvYXQoIHZhbHVlICkgKSApIHtcblx0XHRcdFx0XHRkaWZmWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkaWZmO1xufVxuXG4vLyBTdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJC5mbi5hZGRCYWNrICkge1xuXHQkLmZuLmFkZEJhY2sgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9O1xufVxuXG4kLmVmZmVjdHMuYW5pbWF0ZUNsYXNzID0gZnVuY3Rpb24oIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0dmFyIG8gPSAkLnNwZWVkKCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0ZWQgPSAkKCB0aGlzICksXG5cdFx0XHRiYXNlQ2xhc3MgPSBhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIgKSB8fCBcIlwiLFxuXHRcdFx0YXBwbHlDbGFzc0NoYW5nZSxcblx0XHRcdGFsbEFuaW1hdGlvbnMgPSBvLmNoaWxkcmVuID8gYW5pbWF0ZWQuZmluZCggXCIqXCIgKS5hZGRCYWNrKCkgOiBhbmltYXRlZDtcblxuXHRcdC8vIE1hcCB0aGUgYW5pbWF0ZWQgb2JqZWN0cyB0byBzdG9yZSB0aGUgb3JpZ2luYWwgc3R5bGVzLlxuXHRcdGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWwgPSAkKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbDogZWwsXG5cdFx0XHRcdHN0YXJ0OiBnZXRFbGVtZW50U3R5bGVzKCB0aGlzIClcblx0XHRcdH07XG5cdFx0fSApO1xuXG5cdFx0Ly8gQXBwbHkgY2xhc3MgY2hhbmdlXG5cdFx0YXBwbHlDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC5lYWNoKCBjbGFzc0FuaW1hdGlvbkFjdGlvbnMsIGZ1bmN0aW9uKCBpLCBhY3Rpb24gKSB7XG5cdFx0XHRcdGlmICggdmFsdWVbIGFjdGlvbiBdICkge1xuXHRcdFx0XHRcdGFuaW1hdGVkWyBhY3Rpb24gKyBcIkNsYXNzXCIgXSggdmFsdWVbIGFjdGlvbiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdGFwcGx5Q2xhc3NDaGFuZ2UoKTtcblxuXHRcdC8vIE1hcCBhbGwgYW5pbWF0ZWQgb2JqZWN0cyBhZ2FpbiAtIGNhbGN1bGF0ZSBuZXcgc3R5bGVzIGFuZCBkaWZmXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZW5kID0gZ2V0RWxlbWVudFN0eWxlcyggdGhpcy5lbFsgMCBdICk7XG5cdFx0XHR0aGlzLmRpZmYgPSBzdHlsZURpZmZlcmVuY2UoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9ICk7XG5cblx0XHQvLyBBcHBseSBvcmlnaW5hbCBjbGFzc1xuXHRcdGFuaW1hdGVkLmF0dHIoIFwiY2xhc3NcIiwgYmFzZUNsYXNzICk7XG5cblx0XHQvLyBNYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSB0aGlzIHRpbWUgY29sbGVjdGluZyBhIHByb21pc2Vcblx0XHRhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0eWxlSW5mbyA9IHRoaXMsXG5cdFx0XHRcdGRmZCA9ICQuRGVmZXJyZWQoKSxcblx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKCB7fSwgbywge1xuXHRcdFx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkZmQucmVzb2x2ZSggc3R5bGVJbmZvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZWwuYW5pbWF0ZSggdGhpcy5kaWZmLCBvcHRzICk7XG5cdFx0XHRyZXR1cm4gZGZkLnByb21pc2UoKTtcblx0XHR9ICk7XG5cblx0XHQvLyBPbmNlIGFsbCBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkOlxuXHRcdCQud2hlbi5hcHBseSggJCwgYWxsQW5pbWF0aW9ucy5nZXQoKSApLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTZXQgdGhlIGZpbmFsIGNsYXNzXG5cdFx0XHRhcHBseUNsYXNzQ2hhbmdlKCk7XG5cblx0XHRcdC8vIEZvciBlYWNoIGFuaW1hdGVkIGVsZW1lbnQsXG5cdFx0XHQvLyBjbGVhciBhbGwgY3NzIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFuaW1hdGVkXG5cdFx0XHQkLmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbCA9IHRoaXMuZWw7XG5cdFx0XHRcdCQuZWFjaCggdGhpcy5kaWZmLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdGVsLmNzcygga2V5LCBcIlwiICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gVGhpcyBpcyBndWFybnRlZWQgdG8gYmUgdGhlcmUgaWYgeW91IHVzZSBqUXVlcnkuc3BlZWQoKVxuXHRcdFx0Ly8gaXQgYWxzbyBoYW5kbGVzIGRlcXVldWluZyB0aGUgbmV4dCBhbmltLi4uXG5cdFx0XHRvLmNvbXBsZXRlLmNhbGwoIGFuaW1hdGVkWyAwIF0gKTtcblx0XHR9ICk7XG5cdH0gKTtcbn07XG5cbiQuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4gc3BlZWQgP1xuXHRcdFx0XHQkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0eyBhZGQ6IGNsYXNzTmFtZXMgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0gKSggJC5mbi5hZGRDbGFzcyApLFxuXG5cdHJlbW92ZUNsYXNzOiAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgP1xuXHRcdFx0XHQkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0eyByZW1vdmU6IGNsYXNzTmFtZXMgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0gKSggJC5mbi5yZW1vdmVDbGFzcyApLFxuXG5cdHRvZ2dsZUNsYXNzOiAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggY2xhc3NOYW1lcywgZm9yY2UsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgZm9yY2UgPT09IFwiYm9vbGVhblwiIHx8IGZvcmNlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlmICggIXNwZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2l0aG91dCBzcGVlZCBwYXJhbWV0ZXJcblx0XHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcblx0XHRcdFx0XHRcdCggZm9yY2UgPyB7IGFkZDogY2xhc3NOYW1lcyB9IDogeyByZW1vdmU6IGNsYXNzTmFtZXMgfSApLFxuXHRcdFx0XHRcdFx0c3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBXaXRob3V0IGZvcmNlIHBhcmFtZXRlclxuXHRcdFx0XHRyZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHRcdHsgdG9nZ2xlOiBjbGFzc05hbWVzIH0sIGZvcmNlLCBzcGVlZCwgZWFzaW5nICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApKCAkLmZuLnRvZ2dsZUNsYXNzICksXG5cblx0c3dpdGNoQ2xhc3M6IGZ1bmN0aW9uKCByZW1vdmUsIGFkZCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcywge1xuXHRcdFx0YWRkOiBhZGQsXG5cdFx0XHRyZW1vdmU6IHJlbW92ZVxuXHRcdH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH1cbn0gKTtcblxufSApKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRUZGRUNUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuKCBmdW5jdGlvbigpIHtcblxuaWYgKCAkLmV4cHIgJiYgJC5leHByLmZpbHRlcnMgJiYgJC5leHByLmZpbHRlcnMuYW5pbWF0ZWQgKSB7XG5cdCQuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gISEkKCBlbGVtICkuZGF0YSggZGF0YVNwYWNlQW5pbWF0ZWQgKSB8fCBvcmlnKCBlbGVtICk7XG5cdFx0fTtcblx0fSApKCAkLmV4cHIuZmlsdGVycy5hbmltYXRlZCApO1xufVxuXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblx0JC5leHRlbmQoICQuZWZmZWN0cywge1xuXG5cdFx0Ly8gU2F2ZXMgYSBzZXQgb2YgcHJvcGVydGllcyBpbiBhIGRhdGEgc3RvcmFnZVxuXHRcdHNhdmU6IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXQgKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGxlbmd0aCA9IHNldC5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRlbGVtZW50LmRhdGEoIGRhdGFTcGFjZSArIHNldFsgaSBdLCBlbGVtZW50WyAwIF0uc3R5bGVbIHNldFsgaSBdIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBSZXN0b3JlcyBhIHNldCBvZiBwcmV2aW91c2x5IHNhdmVkIHByb3BlcnRpZXMgZnJvbSBhIGRhdGEgc3RvcmFnZVxuXHRcdHJlc3RvcmU6IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXQgKSB7XG5cdFx0XHR2YXIgdmFsLCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNldFsgaSBdICE9PSBudWxsICkge1xuXHRcdFx0XHRcdHZhbCA9IGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlICsgc2V0WyBpIF0gKTtcblx0XHRcdFx0XHRlbGVtZW50LmNzcyggc2V0WyBpIF0sIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldE1vZGU6IGZ1bmN0aW9uKCBlbCwgbW9kZSApIHtcblx0XHRcdGlmICggbW9kZSA9PT0gXCJ0b2dnbGVcIiApIHtcblx0XHRcdFx0bW9kZSA9IGVsLmlzKCBcIjpoaWRkZW5cIiApID8gXCJzaG93XCIgOiBcImhpZGVcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtb2RlO1xuXHRcdH0sXG5cblx0XHQvLyBXcmFwcyB0aGUgZWxlbWVudCBhcm91bmQgYSB3cmFwcGVyIHRoYXQgY29waWVzIHBvc2l0aW9uIHByb3BlcnRpZXNcblx0XHRjcmVhdGVXcmFwcGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB3cmFwcGVkLCByZXR1cm4gaXRcblx0XHRcdGlmICggZWxlbWVudC5wYXJlbnQoKS5pcyggXCIudWktZWZmZWN0cy13cmFwcGVyXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdyYXAgdGhlIGVsZW1lbnRcblx0XHRcdHZhciBwcm9wcyA9IHtcblx0XHRcdFx0XHR3aWR0aDogZWxlbWVudC5vdXRlcldpZHRoKCB0cnVlICksXG5cdFx0XHRcdFx0aGVpZ2h0OiBlbGVtZW50Lm91dGVySGVpZ2h0KCB0cnVlICksXG5cdFx0XHRcdFx0XCJmbG9hdFwiOiBlbGVtZW50LmNzcyggXCJmbG9hdFwiIClcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcHBlciA9ICQoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtd3JhcHBlclwiIClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRmb250U2l6ZTogXCIxMDAlXCIsXG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG5cdFx0XHRcdFx0XHRib3JkZXI6IFwibm9uZVwiLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMFxuXHRcdFx0XHRcdH0gKSxcblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgc2l6ZSBpbiBjYXNlIHdpZHRoL2hlaWdodCBhcmUgZGVmaW5lZCBpbiAlIC0gRml4ZXMgIzUyNDVcblx0XHRcdFx0c2l6ZSA9IHtcblx0XHRcdFx0XHR3aWR0aDogZWxlbWVudC53aWR0aCgpLFxuXHRcdFx0XHRcdGhlaWdodDogZWxlbWVudC5oZWlnaHQoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94XG5cdFx0XHQvLyBGaXJlZm94IGluY29ycmVjdGx5IGV4cG9zZXMgYW5vbnltb3VzIGNvbnRlbnRcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU2MTY2NFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YWN0aXZlLmlkO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQud3JhcCggd3JhcHBlciApO1xuXG5cdFx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdFx0aWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuXHRcdFx0XHQkKCBhY3RpdmUgKS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG90Zml4IGZvciBqUXVlcnkgMS40IHNpbmNlIHNvbWUgY2hhbmdlIGluIHdyYXAoKSBzZWVtcyB0byBhY3R1YWxseVxuXHRcdFx0Ly8gbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnRcblx0XHRcdHdyYXBwZXIgPSBlbGVtZW50LnBhcmVudCgpO1xuXG5cdFx0XHQvLyBUcmFuc2ZlciBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzIHRvIHRoZSB3cmFwcGVyXG5cdFx0XHRpZiAoIGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0d3JhcHBlci5jc3MoIHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9ICk7XG5cdFx0XHRcdGVsZW1lbnQuY3NzKCB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JC5leHRlbmQoIHByb3BzLCB7XG5cdFx0XHRcdFx0cG9zaXRpb246IGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdFx0XHR6SW5kZXg6IGVsZW1lbnQuY3NzKCBcInotaW5kZXhcIiApXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0JC5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiLCBcImJvdHRvbVwiLCBcInJpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIHBvcyApIHtcblx0XHRcdFx0XHRwcm9wc1sgcG9zIF0gPSBlbGVtZW50LmNzcyggcG9zICk7XG5cdFx0XHRcdFx0aWYgKCBpc05hTiggcGFyc2VJbnQoIHByb3BzWyBwb3MgXSwgMTAgKSApICkge1xuXHRcdFx0XHRcdFx0cHJvcHNbIHBvcyBdID0gXCJhdXRvXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGVsZW1lbnQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwicmVsYXRpdmVcIixcblx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRyaWdodDogXCJhdXRvXCIsXG5cdFx0XHRcdFx0Ym90dG9tOiBcImF1dG9cIlxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LmNzcyggc2l6ZSApO1xuXG5cdFx0XHRyZXR1cm4gd3JhcHBlci5jc3MoIHByb3BzICkuc2hvdygpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVXcmFwcGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkgKSB7XG5cdFx0XHRcdGVsZW1lbnQucGFyZW50KCkucmVwbGFjZVdpdGgoIGVsZW1lbnQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdFx0XHRpZiAoIGVsZW1lbnRbIDAgXSA9PT0gYWN0aXZlIHx8ICQuY29udGFpbnMoIGVsZW1lbnRbIDAgXSwgYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0JCggYWN0aXZlICkudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHR9ICk7XG59XG5cbiQuZXh0ZW5kKCAkLmVmZmVjdHMsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblxuXHRkZWZpbmU6IGZ1bmN0aW9uKCBuYW1lLCBtb2RlLCBlZmZlY3QgKSB7XG5cdFx0aWYgKCAhZWZmZWN0ICkge1xuXHRcdFx0ZWZmZWN0ID0gbW9kZTtcblx0XHRcdG1vZGUgPSBcImVmZmVjdFwiO1xuXHRcdH1cblxuXHRcdCQuZWZmZWN0cy5lZmZlY3RbIG5hbWUgXSA9IGVmZmVjdDtcblx0XHQkLmVmZmVjdHMuZWZmZWN0WyBuYW1lIF0ubW9kZSA9IG1vZGU7XG5cblx0XHRyZXR1cm4gZWZmZWN0O1xuXHR9LFxuXG5cdHNjYWxlZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCBlbGVtZW50LCBwZXJjZW50LCBkaXJlY3Rpb24gKSB7XG5cdFx0aWYgKCBwZXJjZW50ID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aGVpZ2h0OiAwLFxuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6IDAsXG5cdFx0XHRcdG91dGVyV2lkdGg6IDBcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIHggPSBkaXJlY3Rpb24gIT09IFwiaG9yaXpvbnRhbFwiID8gKCAoIHBlcmNlbnQgfHwgMTAwICkgLyAxMDAgKSA6IDEsXG5cdFx0XHR5ID0gZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIgPyAoICggcGVyY2VudCB8fCAxMDAgKSAvIDEwMCApIDogMTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0KCkgKiB5LFxuXHRcdFx0d2lkdGg6IGVsZW1lbnQud2lkdGgoKSAqIHgsXG5cdFx0XHRvdXRlckhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCgpICogeSxcblx0XHRcdG91dGVyV2lkdGg6IGVsZW1lbnQub3V0ZXJXaWR0aCgpICogeFxuXHRcdH07XG5cblx0fSxcblxuXHRjbGlwVG9Cb3g6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBhbmltYXRpb24uY2xpcC5yaWdodCAtIGFuaW1hdGlvbi5jbGlwLmxlZnQsXG5cdFx0XHRoZWlnaHQ6IGFuaW1hdGlvbi5jbGlwLmJvdHRvbSAtIGFuaW1hdGlvbi5jbGlwLnRvcCxcblx0XHRcdGxlZnQ6IGFuaW1hdGlvbi5jbGlwLmxlZnQsXG5cdFx0XHR0b3A6IGFuaW1hdGlvbi5jbGlwLnRvcFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gSW5qZWN0cyByZWNlbnRseSBxdWV1ZWQgZnVuY3Rpb25zIHRvIGJlIGZpcnN0IGluIGxpbmUgKGFmdGVyIFwiaW5wcm9ncmVzc1wiKVxuXHR1bnNoaWZ0OiBmdW5jdGlvbiggZWxlbWVudCwgcXVldWVMZW5ndGgsIGNvdW50ICkge1xuXHRcdHZhciBxdWV1ZSA9IGVsZW1lbnQucXVldWUoKTtcblxuXHRcdGlmICggcXVldWVMZW5ndGggPiAxICkge1xuXHRcdFx0cXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcblx0XHRcdFx0WyAxLCAwIF0uY29uY2F0KCBxdWV1ZS5zcGxpY2UoIHF1ZXVlTGVuZ3RoLCBjb3VudCApICkgKTtcblx0XHR9XG5cdFx0ZWxlbWVudC5kZXF1ZXVlKCk7XG5cdH0sXG5cblx0c2F2ZVN0eWxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRlbGVtZW50LmRhdGEoIGRhdGFTcGFjZVN0eWxlLCBlbGVtZW50WyAwIF0uc3R5bGUuY3NzVGV4dCApO1xuXHR9LFxuXG5cdHJlc3RvcmVTdHlsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudFsgMCBdLnN0eWxlLmNzc1RleHQgPSBlbGVtZW50LmRhdGEoIGRhdGFTcGFjZVN0eWxlICkgfHwgXCJcIjtcblx0XHRlbGVtZW50LnJlbW92ZURhdGEoIGRhdGFTcGFjZVN0eWxlICk7XG5cdH0sXG5cblx0bW9kZTogZnVuY3Rpb24oIGVsZW1lbnQsIG1vZGUgKSB7XG5cdFx0dmFyIGhpZGRlbiA9IGVsZW1lbnQuaXMoIFwiOmhpZGRlblwiICk7XG5cblx0XHRpZiAoIG1vZGUgPT09IFwidG9nZ2xlXCIgKSB7XG5cdFx0XHRtb2RlID0gaGlkZGVuID8gXCJzaG93XCIgOiBcImhpZGVcIjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gPyBtb2RlID09PSBcImhpZGVcIiA6IG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdFx0bW9kZSA9IFwibm9uZVwiO1xuXHRcdH1cblx0XHRyZXR1cm4gbW9kZTtcblx0fSxcblxuXHQvLyBUcmFuc2xhdGVzIGEgW3RvcCxsZWZ0XSBhcnJheSBpbnRvIGEgYmFzZWxpbmUgdmFsdWVcblx0Z2V0QmFzZWxpbmU6IGZ1bmN0aW9uKCBvcmlnaW4sIG9yaWdpbmFsICkge1xuXHRcdHZhciB5LCB4O1xuXG5cdFx0c3dpdGNoICggb3JpZ2luWyAwIF0gKSB7XG5cdFx0Y2FzZSBcInRvcFwiOlxuXHRcdFx0eSA9IDA7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwibWlkZGxlXCI6XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcImJvdHRvbVwiOlxuXHRcdFx0eSA9IDE7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0eSA9IG9yaWdpblsgMCBdIC8gb3JpZ2luYWwuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIG9yaWdpblsgMSBdICkge1xuXHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0XHR4ID0gMDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJjZW50ZXJcIjpcblx0XHRcdHggPSAwLjU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRcdHggPSAxO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHggPSBvcmlnaW5bIDEgXSAvIG9yaWdpbmFsLndpZHRoO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIHBsYWNlaG9sZGVyIGVsZW1lbnQgc28gdGhhdCB0aGUgb3JpZ2luYWwgZWxlbWVudCBjYW4gYmUgbWFkZSBhYnNvbHV0ZVxuXHRjcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHBsYWNlaG9sZGVyLFxuXHRcdFx0Y3NzUG9zaXRpb24gPSBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRwb3NpdGlvbiA9IGVsZW1lbnQucG9zaXRpb24oKTtcblxuXHRcdC8vIExvY2sgaW4gbWFyZ2lucyBmaXJzdCB0byBhY2NvdW50IGZvciBmb3JtIGVsZW1lbnRzLCB3aGljaFxuXHRcdC8vIHdpbGwgY2hhbmdlIG1hcmdpbiBpZiB5b3UgZXhwbGljaXRseSBzZXQgaGVpZ2h0XG5cdFx0Ly8gc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L0paU010LzMvIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDczODBcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmlcblx0XHRlbGVtZW50LmNzcygge1xuXHRcdFx0bWFyZ2luVG9wOiBlbGVtZW50LmNzcyggXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0bWFyZ2luQm90dG9tOiBlbGVtZW50LmNzcyggXCJtYXJnaW5Cb3R0b21cIiApLFxuXHRcdFx0bWFyZ2luTGVmdDogZWxlbWVudC5jc3MoIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRtYXJnaW5SaWdodDogZWxlbWVudC5jc3MoIFwibWFyZ2luUmlnaHRcIiApXG5cdFx0fSApXG5cdFx0Lm91dGVyV2lkdGgoIGVsZW1lbnQub3V0ZXJXaWR0aCgpIClcblx0XHQub3V0ZXJIZWlnaHQoIGVsZW1lbnQub3V0ZXJIZWlnaHQoKSApO1xuXG5cdFx0aWYgKCAvXihzdGF0aWN8cmVsYXRpdmUpLy50ZXN0KCBjc3NQb3NpdGlvbiApICkge1xuXHRcdFx0Y3NzUG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cblx0XHRcdHBsYWNlaG9sZGVyID0gJCggXCI8XCIgKyBlbGVtZW50WyAwIF0ubm9kZU5hbWUgKyBcIj5cIiApLmluc2VydEFmdGVyKCBlbGVtZW50ICkuY3NzKCB7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBpbmxpbmUgdG8gaW5saW5lIGJsb2NrIHRvIGFjY291bnQgZm9yIGlubGluZSBlbGVtZW50c1xuXHRcdFx0XHQvLyB0aGF0IHR1cm4gdG8gaW5saW5lIGJsb2NrIGJhc2VkIG9uIGNvbnRlbnQgKGxpa2UgaW1nKVxuXHRcdFx0XHRkaXNwbGF5OiAvXihpbmxpbmV8cnVieSkvLnRlc3QoIGVsZW1lbnQuY3NzKCBcImRpc3BsYXlcIiApICkgP1xuXHRcdFx0XHRcdFwiaW5saW5lLWJsb2NrXCIgOlxuXHRcdFx0XHRcdFwiYmxvY2tcIixcblx0XHRcdFx0dmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblxuXHRcdFx0XHQvLyBNYXJnaW5zIG5lZWQgdG8gYmUgc2V0IHRvIGFjY291bnQgZm9yIG1hcmdpbiBjb2xsYXBzZVxuXHRcdFx0XHRtYXJnaW5Ub3A6IGVsZW1lbnQuY3NzKCBcIm1hcmdpblRvcFwiICksXG5cdFx0XHRcdG1hcmdpbkJvdHRvbTogZWxlbWVudC5jc3MoIFwibWFyZ2luQm90dG9tXCIgKSxcblx0XHRcdFx0bWFyZ2luTGVmdDogZWxlbWVudC5jc3MoIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBlbGVtZW50LmNzcyggXCJtYXJnaW5SaWdodFwiICksXG5cdFx0XHRcdFwiZmxvYXRcIjogZWxlbWVudC5jc3MoIFwiZmxvYXRcIiApXG5cdFx0XHR9IClcblx0XHRcdC5vdXRlcldpZHRoKCBlbGVtZW50Lm91dGVyV2lkdGgoKSApXG5cdFx0XHQub3V0ZXJIZWlnaHQoIGVsZW1lbnQub3V0ZXJIZWlnaHQoKSApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktZWZmZWN0cy1wbGFjZWhvbGRlclwiICk7XG5cblx0XHRcdGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlICsgXCJwbGFjZWhvbGRlclwiLCBwbGFjZWhvbGRlciApO1xuXHRcdH1cblxuXHRcdGVsZW1lbnQuY3NzKCB7XG5cdFx0XHRwb3NpdGlvbjogY3NzUG9zaXRpb24sXG5cdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0dG9wOiBwb3NpdGlvbi50b3Bcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gcGxhY2Vob2xkZXI7XG5cdH0sXG5cblx0cmVtb3ZlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBkYXRhS2V5ID0gZGF0YVNwYWNlICsgXCJwbGFjZWhvbGRlclwiLFxuXHRcdFx0XHRwbGFjZWhvbGRlciA9IGVsZW1lbnQuZGF0YSggZGF0YUtleSApO1xuXG5cdFx0aWYgKCBwbGFjZWhvbGRlciApIHtcblx0XHRcdHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVEYXRhKCBkYXRhS2V5ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFJlbW92ZXMgYSBwbGFjZWhvbGRlciBpZiBpdCBleGlzdHMgYW5kIHJlc3RvcmVzXG5cdC8vIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG1vZGlmaWVkIGR1cmluZyBwbGFjZWhvbGRlciBjcmVhdGlvblxuXHRjbGVhblVwOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHQkLmVmZmVjdHMucmVzdG9yZVN0eWxlKCBlbGVtZW50ICk7XG5cdFx0JC5lZmZlY3RzLnJlbW92ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cdH0sXG5cblx0c2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oIGVsZW1lbnQsIGxpc3QsIGZhY3RvciwgdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSB8fCB7fTtcblx0XHQkLmVhY2goIGxpc3QsIGZ1bmN0aW9uKCBpLCB4ICkge1xuXHRcdFx0dmFyIHVuaXQgPSBlbGVtZW50LmNzc1VuaXQoIHggKTtcblx0XHRcdGlmICggdW5pdFsgMCBdID4gMCApIHtcblx0XHRcdFx0dmFsdWVbIHggXSA9IHVuaXRbIDAgXSAqIGZhY3RvciArIHVuaXRbIDEgXTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59ICk7XG5cbi8vIFJldHVybiBhbiBlZmZlY3Qgb3B0aW9ucyBvYmplY3QgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzOlxuZnVuY3Rpb24gX25vcm1hbGl6ZUFyZ3VtZW50cyggZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2sgKSB7XG5cblx0Ly8gQWxsb3cgcGFzc2luZyBhbGwgb3B0aW9ucyBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBlZmZlY3QgKSApIHtcblx0XHRvcHRpb25zID0gZWZmZWN0O1xuXHRcdGVmZmVjdCA9IGVmZmVjdC5lZmZlY3Q7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRvIGFuIG9iamVjdFxuXHRlZmZlY3QgPSB7IGVmZmVjdDogZWZmZWN0IH07XG5cblx0Ly8gQ2F0Y2ggKGVmZmVjdCwgbnVsbCwgLi4uKVxuXHRpZiAoIG9wdGlvbnMgPT0gbnVsbCApIHtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBDYXRjaCAoZWZmZWN0LCBjYWxsYmFjaylcblx0aWYgKCAkLmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0c3BlZWQgPSBudWxsO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdC8vIENhdGNoIChlZmZlY3QsIHNwZWVkLCA/KVxuXHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiIHx8ICQuZnguc3BlZWRzWyBvcHRpb25zIF0gKSB7XG5cdFx0Y2FsbGJhY2sgPSBzcGVlZDtcblx0XHRzcGVlZCA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gQ2F0Y2ggKGVmZmVjdCwgb3B0aW9ucywgY2FsbGJhY2spXG5cdGlmICggJC5pc0Z1bmN0aW9uKCBzcGVlZCApICkge1xuXHRcdGNhbGxiYWNrID0gc3BlZWQ7XG5cdFx0c3BlZWQgPSBudWxsO1xuXHR9XG5cblx0Ly8gQWRkIG9wdGlvbnMgdG8gZWZmZWN0XG5cdGlmICggb3B0aW9ucyApIHtcblx0XHQkLmV4dGVuZCggZWZmZWN0LCBvcHRpb25zICk7XG5cdH1cblxuXHRzcGVlZCA9IHNwZWVkIHx8IG9wdGlvbnMuZHVyYXRpb247XG5cdGVmZmVjdC5kdXJhdGlvbiA9ICQuZngub2ZmID8gMCA6XG5cdFx0dHlwZW9mIHNwZWVkID09PSBcIm51bWJlclwiID8gc3BlZWQgOlxuXHRcdHNwZWVkIGluICQuZnguc3BlZWRzID8gJC5meC5zcGVlZHNbIHNwZWVkIF0gOlxuXHRcdCQuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdGVmZmVjdC5jb21wbGV0ZSA9IGNhbGxiYWNrIHx8IG9wdGlvbnMuY29tcGxldGU7XG5cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApIHtcblxuXHQvLyBWYWxpZCBzdGFuZGFyZCBzcGVlZHMgKG5vdGhpbmcsIG51bWJlciwgbmFtZWQgc3BlZWQpXG5cdGlmICggIW9wdGlvbiB8fCB0eXBlb2Ygb3B0aW9uID09PSBcIm51bWJlclwiIHx8ICQuZnguc3BlZWRzWyBvcHRpb24gXSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludmFsaWQgc3RyaW5ncyAtIHRyZWF0IGFzIFwibm9ybWFsXCIgc3BlZWRcblx0aWYgKCB0eXBlb2Ygb3B0aW9uID09PSBcInN0cmluZ1wiICYmICEkLmVmZmVjdHMuZWZmZWN0WyBvcHRpb24gXSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIENvbXBsZXRlIGNhbGxiYWNrXG5cdGlmICggJC5pc0Z1bmN0aW9uKCBvcHRpb24gKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIE9wdGlvbnMgaGFzaCAoYnV0IG5vdCBuYW1pbmcgYW4gZWZmZWN0KVxuXHRpZiAoIHR5cGVvZiBvcHRpb24gPT09IFwib2JqZWN0XCIgJiYgIW9wdGlvbi5lZmZlY3QgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBEaWRuJ3QgbWF0Y2ggYW55IHN0YW5kYXJkIEFQSVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbiQuZm4uZXh0ZW5kKCB7XG5cdGVmZmVjdDogZnVuY3Rpb24oIC8qIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICovICkge1xuXHRcdHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICksXG5cdFx0XHRlZmZlY3RNZXRob2QgPSAkLmVmZmVjdHMuZWZmZWN0WyBhcmdzLmVmZmVjdCBdLFxuXHRcdFx0ZGVmYXVsdE1vZGUgPSBlZmZlY3RNZXRob2QubW9kZSxcblx0XHRcdHF1ZXVlID0gYXJncy5xdWV1ZSxcblx0XHRcdHF1ZXVlTmFtZSA9IHF1ZXVlIHx8IFwiZnhcIixcblx0XHRcdGNvbXBsZXRlID0gYXJncy5jb21wbGV0ZSxcblx0XHRcdG1vZGUgPSBhcmdzLm1vZGUsXG5cdFx0XHRtb2RlcyA9IFtdLFxuXHRcdFx0cHJlZmlsdGVyID0gZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRub3JtYWxpemVkTW9kZSA9ICQuZWZmZWN0cy5tb2RlKCBlbCwgbW9kZSApIHx8IGRlZmF1bHRNb2RlO1xuXG5cdFx0XHRcdC8vIFNlbnRpbmVsIGZvciBkdWNrLXB1bmNoaW5nIHRoZSA6YW5pbWF0ZWQgcHN1ZWRvLXNlbGVjdG9yXG5cdFx0XHRcdGVsLmRhdGEoIGRhdGFTcGFjZUFuaW1hdGVkLCB0cnVlICk7XG5cblx0XHRcdFx0Ly8gU2F2ZSBlZmZlY3QgbW9kZSBmb3IgbGF0ZXIgdXNlLFxuXHRcdFx0XHQvLyB3ZSBjYW4ndCBqdXN0IGNhbGwgJC5lZmZlY3RzLm1vZGUgYWdhaW4gbGF0ZXIsXG5cdFx0XHRcdC8vIGFzIHRoZSAuc2hvdygpIGJlbG93IGRlc3Ryb3lzIHRoZSBpbml0aWFsIHN0YXRlXG5cdFx0XHRcdG1vZGVzLnB1c2goIG5vcm1hbGl6ZWRNb2RlICk7XG5cblx0XHRcdFx0Ly8gU2VlICQudWlCYWNrQ29tcGF0IGluc2lkZSBvZiBydW4oKSBmb3IgcmVtb3ZhbCBvZiBkZWZhdWx0TW9kZSBpbiAxLjEzXG5cdFx0XHRcdGlmICggZGVmYXVsdE1vZGUgJiYgKCBub3JtYWxpemVkTW9kZSA9PT0gXCJzaG93XCIgfHxcblx0XHRcdFx0XHRcdCggbm9ybWFsaXplZE1vZGUgPT09IGRlZmF1bHRNb2RlICYmIG5vcm1hbGl6ZWRNb2RlID09PSBcImhpZGVcIiApICkgKSB7XG5cdFx0XHRcdFx0ZWwuc2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhZGVmYXVsdE1vZGUgfHwgbm9ybWFsaXplZE1vZGUgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdCQuZWZmZWN0cy5zYXZlU3R5bGUoIGVsICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggbmV4dCApICkge1xuXHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggJC5meC5vZmYgfHwgIWVmZmVjdE1ldGhvZCApIHtcblxuXHRcdFx0Ly8gRGVsZWdhdGUgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoZS5nLiwgLnNob3coKSkgaWYgcG9zc2libGVcblx0XHRcdGlmICggbW9kZSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXNbIG1vZGUgXSggYXJncy5kdXJhdGlvbiwgY29tcGxldGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRjb21wbGV0ZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuKCBuZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICk7XG5cblx0XHRcdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlRGF0YSggZGF0YVNwYWNlQW5pbWF0ZWQgKTtcblxuXHRcdFx0XHQkLmVmZmVjdHMuY2xlYW5VcCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggYXJncy5tb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0XHRlbGVtLmhpZGUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZG9uZSgpIHtcblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGNvbXBsZXRlICkgKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUuY2FsbCggZWxlbVsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggbmV4dCApICkge1xuXHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtb2RlIG9wdGlvbiBvbiBhIHBlciBlbGVtZW50IGJhc2lzLFxuXHRcdFx0Ly8gYXMgdG9nZ2xlIGNhbiBiZSBlaXRoZXIgc2hvdyBvciBoaWRlIGRlcGVuZGluZyBvbiBlbGVtZW50IHN0YXRlXG5cdFx0XHRhcmdzLm1vZGUgPSBtb2Rlcy5zaGlmdCgpO1xuXG5cdFx0XHRpZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSAmJiAhZGVmYXVsdE1vZGUgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5pcyggXCI6aGlkZGVuXCIgKSA/IG1vZGUgPT09IFwiaGlkZVwiIDogbW9kZSA9PT0gXCJzaG93XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYWxsIHRoZSBjb3JlIG1ldGhvZCB0byB0cmFjayBcIm9sZGRpc3BsYXlcIiBwcm9wZXJseVxuXHRcdFx0XHRcdGVsZW1bIG1vZGUgXSgpO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlZmZlY3RNZXRob2QuY2FsbCggZWxlbVsgMCBdLCBhcmdzLCBkb25lICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJncy5tb2RlID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhbGwgdGhlIGNvcmUgbWV0aG9kIHRvIHRyYWNrIFwib2xkZGlzcGxheVwiIHByb3Blcmx5XG5cdFx0XHRcdFx0ZWxlbVsgbW9kZSBdKCk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVmZmVjdE1ldGhvZC5jYWxsKCBlbGVtWyAwIF0sIGFyZ3MsIGNsZWFudXAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJ1biBwcmVmaWx0ZXIgb24gYWxsIGVsZW1lbnRzIGZpcnN0IHRvIGVuc3VyZSB0aGF0XG5cdFx0Ly8gYW55IHNob3dpbmcgb3IgaGlkaW5nIGhhcHBlbnMgYmVmb3JlIHBsYWNlaG9sZGVyIGNyZWF0aW9uLFxuXHRcdC8vIHdoaWNoIGVuc3VyZXMgdGhhdCBhbnkgbGF5b3V0IGNoYW5nZXMgYXJlIGNvcnJlY3RseSBjYXB0dXJlZC5cblx0XHRyZXR1cm4gcXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggcHJlZmlsdGVyICkuZWFjaCggcnVuICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggcXVldWVOYW1lLCBwcmVmaWx0ZXIgKS5xdWV1ZSggcXVldWVOYW1lLCBydW4gKTtcblx0fSxcblxuXHRzaG93OiAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0aWYgKCBzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbiggb3B0aW9uICkgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGFyZ3MubW9kZSA9IFwic2hvd1wiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gKSggJC5mbi5zaG93ICksXG5cblx0aGlkZTogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLm1vZGUgPSBcImhpZGVcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICkoICQuZm4uaGlkZSApLFxuXG5cdHRvZ2dsZTogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApIHx8IHR5cGVvZiBvcHRpb24gPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLm1vZGUgPSBcInRvZ2dsZVwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gKSggJC5mbi50b2dnbGUgKSxcblxuXHRjc3NVbml0OiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuY3NzKCBrZXkgKSxcblx0XHRcdHZhbCA9IFtdO1xuXG5cdFx0JC5lYWNoKCBbIFwiZW1cIiwgXCJweFwiLCBcIiVcIiwgXCJwdFwiIF0sIGZ1bmN0aW9uKCBpLCB1bml0ICkge1xuXHRcdFx0aWYgKCBzdHlsZS5pbmRleE9mKCB1bml0ICkgPiAwICkge1xuXHRcdFx0XHR2YWwgPSBbIHBhcnNlRmxvYXQoIHN0eWxlICksIHVuaXQgXTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHZhbDtcblx0fSxcblxuXHRjc3NDbGlwOiBmdW5jdGlvbiggY2xpcE9iaiApIHtcblx0XHRpZiAoIGNsaXBPYmogKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiY2xpcFwiLCBcInJlY3QoXCIgKyBjbGlwT2JqLnRvcCArIFwicHggXCIgKyBjbGlwT2JqLnJpZ2h0ICsgXCJweCBcIiArXG5cdFx0XHRcdGNsaXBPYmouYm90dG9tICsgXCJweCBcIiArIGNsaXBPYmoubGVmdCArIFwicHgpXCIgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlQ2xpcCggdGhpcy5jc3MoIFwiY2xpcFwiICksIHRoaXMgKTtcblx0fSxcblxuXHR0cmFuc2ZlcjogZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLnRvICksXG5cdFx0XHR0YXJnZXRGaXhlZCA9IHRhcmdldC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIsXG5cdFx0XHRib2R5ID0gJCggXCJib2R5XCIgKSxcblx0XHRcdGZpeFRvcCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxUb3AoKSA6IDAsXG5cdFx0XHRmaXhMZWZ0ID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbExlZnQoKSA6IDAsXG5cdFx0XHRlbmRQb3NpdGlvbiA9IHRhcmdldC5vZmZzZXQoKSxcblx0XHRcdGFuaW1hdGlvbiA9IHtcblx0XHRcdFx0dG9wOiBlbmRQb3NpdGlvbi50b3AgLSBmaXhUb3AsXG5cdFx0XHRcdGxlZnQ6IGVuZFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0LFxuXHRcdFx0XHRoZWlnaHQ6IHRhcmdldC5pbm5lckhlaWdodCgpLFxuXHRcdFx0XHR3aWR0aDogdGFyZ2V0LmlubmVyV2lkdGgoKVxuXHRcdFx0fSxcblx0XHRcdHN0YXJ0UG9zaXRpb24gPSBlbGVtZW50Lm9mZnNldCgpLFxuXHRcdFx0dHJhbnNmZXIgPSAkKCBcIjxkaXYgY2xhc3M9J3VpLWVmZmVjdHMtdHJhbnNmZXInPjwvZGl2PlwiIClcblx0XHRcdFx0LmFwcGVuZFRvKCBcImJvZHlcIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggb3B0aW9ucy5jbGFzc05hbWUgKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0dG9wOiBzdGFydFBvc2l0aW9uLnRvcCAtIGZpeFRvcCxcblx0XHRcdFx0XHRsZWZ0OiBzdGFydFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0LFxuXHRcdFx0XHRcdGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCgpLFxuXHRcdFx0XHRcdHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgoKSxcblx0XHRcdFx0XHRwb3NpdGlvbjogdGFyZ2V0Rml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCJcblx0XHRcdFx0fSApXG5cdFx0XHRcdC5hbmltYXRlKCBhbmltYXRpb24sIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cmFuc2Zlci5yZW1vdmUoKTtcblx0XHRcdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggZG9uZSApICkge1xuXHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHBhcnNlQ2xpcCggc3RyLCBlbGVtZW50ICkge1xuXHRcdHZhciBvdXRlcldpZHRoID0gZWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRvdXRlckhlaWdodCA9IGVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdGNsaXBSZWdleCA9IC9ecmVjdFxcKCgtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0byksP1xccyooLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pLD9cXHMqKC0/XFxkKlxcLj9cXGQqcHh8LT9cXGQrJXxhdXRvKSw/XFxzKigtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0bylcXCkkLyxcblx0XHRcdHZhbHVlcyA9IGNsaXBSZWdleC5leGVjKCBzdHIgKSB8fCBbIFwiXCIsIDAsIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0LCAwIF07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwYXJzZUZsb2F0KCB2YWx1ZXNbIDEgXSApIHx8IDAsXG5cdFx0XHRyaWdodDogdmFsdWVzWyAyIF0gPT09IFwiYXV0b1wiID8gb3V0ZXJXaWR0aCA6IHBhcnNlRmxvYXQoIHZhbHVlc1sgMiBdICksXG5cdFx0XHRib3R0b206IHZhbHVlc1sgMyBdID09PSBcImF1dG9cIiA/IG91dGVySGVpZ2h0IDogcGFyc2VGbG9hdCggdmFsdWVzWyAzIF0gKSxcblx0XHRcdGxlZnQ6IHBhcnNlRmxvYXQoIHZhbHVlc1sgNCBdICkgfHwgMFxuXHRcdH07XG59XG5cbiQuZnguc3RlcC5jbGlwID0gZnVuY3Rpb24oIGZ4ICkge1xuXHRpZiAoICFmeC5jbGlwSW5pdCApIHtcblx0XHRmeC5zdGFydCA9ICQoIGZ4LmVsZW0gKS5jc3NDbGlwKCk7XG5cdFx0aWYgKCB0eXBlb2YgZnguZW5kID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnguZW5kID0gcGFyc2VDbGlwKCBmeC5lbmQsIGZ4LmVsZW0gKTtcblx0XHR9XG5cdFx0ZnguY2xpcEluaXQgPSB0cnVlO1xuXHR9XG5cblx0JCggZnguZWxlbSApLmNzc0NsaXAoIHtcblx0XHR0b3A6IGZ4LnBvcyAqICggZnguZW5kLnRvcCAtIGZ4LnN0YXJ0LnRvcCApICsgZnguc3RhcnQudG9wLFxuXHRcdHJpZ2h0OiBmeC5wb3MgKiAoIGZ4LmVuZC5yaWdodCAtIGZ4LnN0YXJ0LnJpZ2h0ICkgKyBmeC5zdGFydC5yaWdodCxcblx0XHRib3R0b206IGZ4LnBvcyAqICggZnguZW5kLmJvdHRvbSAtIGZ4LnN0YXJ0LmJvdHRvbSApICsgZnguc3RhcnQuYm90dG9tLFxuXHRcdGxlZnQ6IGZ4LnBvcyAqICggZnguZW5kLmxlZnQgLSBmeC5zdGFydC5sZWZ0ICkgKyBmeC5zdGFydC5sZWZ0XG5cdH0gKTtcbn07XG5cbn0gKSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVBU0lORyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiggZnVuY3Rpb24oKSB7XG5cbi8vIEJhc2VkIG9uIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG52YXIgYmFzZUVhc2luZ3MgPSB7fTtcblxuJC5lYWNoKCBbIFwiUXVhZFwiLCBcIkN1YmljXCIsIFwiUXVhcnRcIiwgXCJRdWludFwiLCBcIkV4cG9cIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0YmFzZUVhc2luZ3NbIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBNYXRoLnBvdyggcCwgaSArIDIgKTtcblx0fTtcbn0gKTtcblxuJC5leHRlbmQoIGJhc2VFYXNpbmdzLCB7XG5cdFNpbmU6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJIC8gMiApO1xuXHR9LFxuXHRDaXJjOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCggMSAtIHAgKiBwICk7XG5cdH0sXG5cdEVsYXN0aWM6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwID09PSAwIHx8IHAgPT09IDEgPyBwIDpcblx0XHRcdC1NYXRoLnBvdyggMiwgOCAqICggcCAtIDEgKSApICogTWF0aC5zaW4oICggKCBwIC0gMSApICogODAgLSA3LjUgKSAqIE1hdGguUEkgLyAxNSApO1xuXHR9LFxuXHRCYWNrOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCAqIHAgKiAoIDMgKiBwIC0gMiApO1xuXHR9LFxuXHRCb3VuY2U6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHZhciBwb3cyLFxuXHRcdFx0Ym91bmNlID0gNDtcblxuXHRcdHdoaWxlICggcCA8ICggKCBwb3cyID0gTWF0aC5wb3coIDIsIC0tYm91bmNlICkgKSAtIDEgKSAvIDExICkge31cblx0XHRyZXR1cm4gMSAvIE1hdGgucG93KCA0LCAzIC0gYm91bmNlICkgLSA3LjU2MjUgKiBNYXRoLnBvdyggKCBwb3cyICogMyAtIDIgKSAvIDIyIC0gcCwgMiApO1xuXHR9XG59ICk7XG5cbiQuZWFjaCggYmFzZUVhc2luZ3MsIGZ1bmN0aW9uKCBuYW1lLCBlYXNlSW4gKSB7XG5cdCQuZWFzaW5nWyBcImVhc2VJblwiICsgbmFtZSBdID0gZWFzZUluO1xuXHQkLmVhc2luZ1sgXCJlYXNlT3V0XCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMSAtIGVhc2VJbiggMSAtIHAgKTtcblx0fTtcblx0JC5lYXNpbmdbIFwiZWFzZUluT3V0XCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCA8IDAuNSA/XG5cdFx0XHRlYXNlSW4oIHAgKiAyICkgLyAyIDpcblx0XHRcdDEgLSBlYXNlSW4oIHAgKiAtMiArIDIgKSAvIDI7XG5cdH07XG59ICk7XG5cbn0gKSgpO1xuXG5yZXR1cm4gJC5lZmZlY3RzO1xuXG59ICkgKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxVQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery-ui/ui/effect.js\n");

/***/ }),

/***/ "./node_modules/jquery-ui/ui/effects/effect-highlight.js":
/*!***************************************************************!*\
  !*** ./node_modules/jquery-ui/ui/effects/effect-highlight.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Effects Highlight 1.12.1\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Highlight Effect\n//>>group: Effects\n//>>description: Highlights the background of an element in a defined color for a custom duration.\n//>>docs: http://api.jqueryui.com/highlight-effect/\n//>>demos: http://jqueryui.com/effect/\n\n( function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t\t__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"),\n\t\t\t__webpack_require__(/*! ../version */ \"./node_modules/jquery-ui/ui/version.js\"),\n\t\t\t__webpack_require__(/*! ../effect */ \"./node_modules/jquery-ui/ui/effect.js\")\n\t\t], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}( function( $ ) {\n\nreturn $.effects.define( \"highlight\", \"show\", function( options, done ) {\n\tvar element = $( this ),\n\t\tanimation = {\n\t\t\tbackgroundColor: element.css( \"backgroundColor\" )\n\t\t};\n\n\tif ( options.mode === \"hide\" ) {\n\t\tanimation.opacity = 0;\n\t}\n\n\t$.effects.saveStyle( element );\n\n\telement\n\t\t.css( {\n\t\t\tbackgroundImage: \"none\",\n\t\t\tbackgroundColor: options.color || \"#ffff99\"\n\t\t} )\n\t\t.animate( animation, {\n\t\t\tqueue: false,\n\t\t\tduration: options.duration,\n\t\t\teasing: options.easing,\n\t\t\tcomplete: done\n\t\t} );\n} );\n\n} ) );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL2VmZmVjdHMvZWZmZWN0LWhpZ2hsaWdodC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvZWZmZWN0cy9lZmZlY3QtaGlnaGxpZ2h0LmpzP2Q2MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBIaWdobGlnaHQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEhpZ2hsaWdodCBFZmZlY3Rcbi8vPj5ncm91cDogRWZmZWN0c1xuLy8+PmRlc2NyaXB0aW9uOiBIaWdobGlnaHRzIHRoZSBiYWNrZ3JvdW5kIG9mIGFuIGVsZW1lbnQgaW4gYSBkZWZpbmVkIGNvbG9yIGZvciBhIGN1c3RvbSBkdXJhdGlvbi5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9oaWdobGlnaHQtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFtcblx0XHRcdFwianF1ZXJ5XCIsXG5cdFx0XHRcIi4uL3ZlcnNpb25cIixcblx0XHRcdFwiLi4vZWZmZWN0XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnJldHVybiAkLmVmZmVjdHMuZGVmaW5lKCBcImhpZ2hsaWdodFwiLCBcInNob3dcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuXHRcdGFuaW1hdGlvbiA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZWxlbWVudC5jc3MoIFwiYmFja2dyb3VuZENvbG9yXCIgKVxuXHRcdH07XG5cblx0aWYgKCBvcHRpb25zLm1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdGFuaW1hdGlvbi5vcGFjaXR5ID0gMDtcblx0fVxuXG5cdCQuZWZmZWN0cy5zYXZlU3R5bGUoIGVsZW1lbnQgKTtcblxuXHRlbGVtZW50XG5cdFx0LmNzcygge1xuXHRcdFx0YmFja2dyb3VuZEltYWdlOiBcIm5vbmVcIixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5jb2xvciB8fCBcIiNmZmZmOTlcIlxuXHRcdH0gKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcblx0XHRcdGNvbXBsZXRlOiBkb25lXG5cdFx0fSApO1xufSApO1xuXG59ICkgKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsVUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery-ui/ui/effects/effect-highlight.js\n");

/***/ })

/******/ });